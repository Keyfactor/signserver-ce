<?xml version="1.0"?>
<!-- $Id$ -->

<document>

    <properties>
        <title>SignServer Manual</title>
    </properties>

    <body>

        <chapter name="Introduction" shortname="introduction">
            <section name="Introduction/scope">
                <p>
The SignServer is an application framework performing cryptographic operations
for other applications. It's intended to be used in environments where keys are
supposed to be protected in hardware but it isn't possible to connect such
hardware to existing enterprise applications or where the operations are
considered extra sensitive so the hardware have to protected more carefully.
Another usage is to provide a simplified method to provide signatures in
different application managed from one location in the company.
                </p>
                <p>
The SignServer have been designed for high-availability and can be clustered for maximum
reliability.
                </p>
                <p>
The SignServer comes with a RFC 3161 compliant Time-Stamp signer serving requests through
HTTP or client-authenticated HTTPS. A MRTD (Machine Readable Travel Document, i.e. electronic
passport) signer. A PDF signer that adds a signature automatically to a uploaded PDF document,
ODF signer that adds a signature automatically to uploaded ODF document, OOXML Signer that
adds signature automatically to a uploaded OOXML document, and a validation service used to
lookup the validation of a given certificate.
                </p>
                <p>
                    <a href="../docs/SignServer_Manual_3_0_odt_m6a7f442a.jpg"><img src="../docs/SignServer_Manual_3_0_odt_m6a7f442a.jpg" align="middle" border="0" width="493" height="252" ALT="architecture"/></a><br/>
                    Drawing 1: Overview of a possible set up of a highly available SignServer solution
                </p>
            </section>

            <section name="Changes from previous versions">
                <subsection name="Changes between version 3.2 and 3.3">
                    <ul>
<!-- New major features -->
<!-- New support -->
<!-- New workers -->
<!-- Improvements -->
<!-- Other -->
                        <li>
Clusterclassloader has been removed.
                        </li>

                    </ul>
                </subsection>
                <subsection name="Changes between version 3.1 and 3.2">
                    <ul>
<!-- New major features -->
                        <li>
A new administration web service (WS) for remote administration of SignServer.
                        </li>

                        <li>
A new administration GUI desktop application for managing workers. Supports
key generation and both local and remote administration.
                        </li>

                        <li>
A new client command line interface (CLI) for requesting signing and validation.
                        </li>

<!-- New support -->
                        <li>
Support for GlassFish Server 2.1.1.
                        </li>
                        <li>
Support for JBoss Application Server 5.1.
                        </li>

                        <li>
Support for Oracle Database.
                        </li>

<!-- New workers -->
                        <li>
Worker renewing signers by generating new keys and sending certificate requests
to EJBCA.
                        </li>

<!-- Improvements -->
                        <li>
Better audit and transaction logging.
                        </li>
                        <li>
New build scripts and project structure with the goal of decouple the different
SignServer modules and sub-projects and simplify future development.
                        </li>
                        <li>
Front page listing all demo web pages.
                        </li>

<!-- Other -->
                        <li>
The bundled SMTP server and MailSigner build of SignServer has been removed.
                        </li>

                    </ul>
                </subsection>
                <subsection name="Changes between version 3.0 and 3.1">
                    <ul>
                        <li>
A new Cluster Class Loader, simplifying the management of customized workers in a
cluster. All the resource data including the classes themselves are stored in database and
accessible from all nodes simultaneously. It is also possible to run multiple versions of the
same worker in the same SignServer cluster, this is useful when migrating a worker to new
code since both the old and new worker can be run at the same time.
                        </li>
                        <li>
PDF Signer, Time-Stamp Authority and MRTD and their specific libraries have the
possibility to build into separate module archives (MAR files) that have to be uploaded to
the SignServer installation before usage, if the cluster classloader is enabled (default).
                        </li>
                        <li>
Installation packages for Linux/Windows of both SignServer and MailSigner using
generation software from Bitrock.
                        </li>
                        <li>
New extended module for signing ePassports: MRTD-SOD.
                        </li>
                        <li>
New modules for signing and validating XML documents.
                        </li>
                        <li>
A new ODF Signer module that adds signature to ODF documents, such as : odt,ods,odt
(tested with OpenOffice.org 3.1.0). Simple web page is added where ODF document can be
uploaded for signing, and resulted signed document downloaded.
                        </li>
                        <li>
A new OOXML Signer Module that adds signature to Office Open XML documents, such as
docx,xlsx,pptx (tested with Microsoft Office 2007).Simple web page is added where open
office xml document can be uploaded for signing, and resulted signed document
downloaded.
                        </li>
                        <li>
Validators for several document types as well.
                        </li>
                        <li>
Java 5 is no longer supported.
                        </li>
                        <li>
For minor changes see the change log at http://jira.primekey.se
                        </li>
                </ul>
                </subsection>
                <subsection name="Changes between version 2 and 3">
                    <ul>
                        <li>
Complete refactorisation of J2EE from EJB2 to EJB3 to simplify further development.
                        </li>
                        <li>
Renamed component "Service" to "TimedService" since 3.0 supports other services.
                        </li>
                        <li>
A "TimedService" can now be configured with a 'cron-like' settings to have services
executed in other than just periodical intervals.
                        </li>
                        <li>
A Validation Service API used to validate certificate from different issuers. The Validation
Service API have it's own easy to use Web Service used to integrate with other platforms.
A Group Key Service API used to generate and manage group keys, symmetric or
asymmetric.
                        </li>
                        <li>
Possibility to have customized authorization of requests, not just the built in client certificate
authorization list.
                        </li>
                        <li>
The name SignToken is changed to CryptoToken and introduced a new concept of
ExtendedCryptoToken that supports symmetric operations.
                        </li>
                        <li>
The RMI-SSL interface have been removed and replaced with a JAX-WS interface with a
simple client framework supporting different load-balance or high availability policies.
                        </li>
                        <li>
All request data have changed from serialization to externalization to be easier to translate to
other platforms.
                        </li>
                        <li>
A completely new MailSigner API based upon the JAMES SMTP server to perform
automated cryptographic operations on e-mails very similar to the plug-ins for the
SignServer.
                        </li>
                        <li>
Java 1.4 is no longer supported.
                        </li>
                        <li>
A lot of new JUnit tests in the test suite.
                        </li>
                        <li>
A PDF Signer that can add a signature to a PDF document through a simple HTML
interface.
                        </li>
                        <li>
PKCS11 Crypto Token to connect to different PKCS11 implementations.
                        </li>
                    </ul>
                </subsection>
                <subsection name="Changes between version 1 and 2">
                    <ul>
                        <li>
  signserver_server.property file have been removed and replaced with a global configuration
  store.
                        </li>
                        <li>
  It is now possible to dynamically add and remove available signers
                        </li>
                        <li>
  A new type of component, "Service" that is run on a timely basis, used to perform
  maintenance or report generation.
                        </li>
                        <li>
  Improved cluster deployment functionality.
                        </li>
                        <li>
  New CLI tools to batch configure the SignServer, and to backup a current configuration.
                        </li>
                        <li>
  This makes it possible to set-up a configuration in test environment, dump the configuration
  and configure the same it in production.
                        </li>
                    </ul>
                </subsection>
            </section>

            <section name="Terms Used in This Document">
                <table>
                    <tr><th>Term</th><th>Explanation</th>
                    </tr><tr><td>Signer</td><td>A Processable service performing signatures upon requests. This could be a ready made signer or a custom developed one.</td>
                    </tr><tr><td>Crypto Token (former Sign Token)</td><td>A Crypto Token is a name for the entity containing the private key and is responsible for its cryptographic operations. Every Processable have a Crypto Token that can be a PKCS12, Smart Card or HSM connection.</td>
                    </tr><tr><td>Extended Crypto Token</td><td>An enhanced Crypto Token with support for symmetric key operations.</td>
                    </tr><tr><td>PKCS11CryptoToken</td><td>A Crypto Token able to communicate with Hardware Security Modules through the standard PKCS11 interface.</td>
                    </tr><tr><td>TimedService (former Service)</td><td>A TimedService is a task that is run on a timely basis, performing maintenance tasks like changing active key or generate a report.</td>
                    </tr><tr><td>Worker</td><td>A common name for Processable (Signer or other type of service) and TimedService</td>
                    </tr><tr><td>Processable</td><td>A type of worker that is used to process requests, i.e. not a TimedService.</td>
                    </tr><tr><td>Worker Configuration</td><td>Each Worker can be configured with properties specific for that worker. There are two sets of worker configuration one "Active" that is used by the signer and one "current" which is the one configured by the administrator. The current configuration isn't used in production until the administrator issued the reload command. This makes it possible for the administrator to configure multiple properties and double-check them before they are actually used.</td>
                    </tr><tr><td>Global Configuration Store</td><td>Is a dynamic store used to define available Workers and their Crypto Tokens. But other data that needs to be read globally could be set there as well. The global configuration properties are activated immediately. There are two different scopes for the store data, Global Scope and Node Scope.</td>
                    </tr><tr><td>Global Scope</td><td>Data stored in the global configuration that can be read by all nodes in the cluster.</td>
                    </tr><tr><td>Node Scope</td><td>Data that is node specific and can only be read within the same node.</td>
                    </tr><tr><td>Worker Id</td><td>Unique identifier of a worker, an integer larger than 0</td>
                    </tr><tr><td>Worker Name</td><td>A name used as a human readable synonym for a Worker Id</td>
                    </tr><tr><td>Validation Service </td><td>A Processable that checks if a certificate is valid or not. Have a Default Validation Service implementation that should work in most cases.<br/>A Validation Service should have one or more Validators configured.</td>
                    </tr><tr><td>Group Key Service</td><td>A Processable that can be used to manage, generate and distribute group keys to a set of clients. The service support four types of calls, fetch group key (used by clients), pre-generate group keys, switch encryption key (key used to safely store the group keys in database) and remove group keys.  There exists a Default Group Key Service that should satisfy most use cases.</td>
                    </tr><tr><td>Certificate Validator (former Validator)</td><td>A Certificate Validator is responsible for checking the status of one or more issuer's certificates. This could be as an OCSP client or a CRL checker or just looking up the status in a database.</td>
                    </tr><tr><td>Document Validator</td><td>A Document Validator is validating a signed document by checking its signature and corresponding certificate(s) and returns the validation result.</td>
                    </tr><tr><td>Authorizer</td><td>An interface that enables developers to integrate the authorization parts with existing authorization systems of who is authorized to perform requests to a Processable.</td>
                    </tr><tr><td>Time Stamp Signer</td><td>A Signer that can be used to set up a Timestamp Authority according to RFC 3161. </td>
                    </tr><tr><td>MRTD Signer</td><td>A Signer that performs signatures of MRTD (Machine Readable Travel Documents, i.e. Electronic Passports) blobs.</td>
                    </tr><tr><td>MRTD SOD Signer</td><td>A Signer that creates the complete security object (SOd) for a MRTD (Machine Readable Travel Document, i.e. Electronic Passports) by signing the data groups.</td>
                    </tr><tr><td>PDF Signer</td><td>A Signer that attaches an electronic signature signature to a PDF document.</td>
                    </tr><tr><td>XML Signer</td><td>A Signer that puts in an enveloped signature in XML documents (XMLDSig)</td>
                    </tr><tr><td>XML Validator</td><td>A Document Validator that validates signed XML documents (XMLDSig)</td>
                    </tr><tr><td>ODF Signer</td><td>A Signer that attaches an electronic signature to an ODF document. ODF Signer is tested with documents produced by <a href="http://www.openoffice.org">OpenOffice.org v 3.1.0</a></td>
                    </tr><tr><td>ODF (Open Document Format) Document</td><td>XML-based file format for representing electronic documents such as spreadsheets, charts, presentations and word processing documents. <a href="http://en.wikipedia.org/wiki/OpenDocument">more...</a></td>
                    </tr><tr><td>OOXML (Office Open XML) Document</td><td>XML-based file format  for representing spreadsheets, charts, presentations and word processing documents. <a href="http://en.wikipedia.org/wiki/Office_Open_XML">more...</a></td>
                    </tr><tr><td>OOXML Signer</td><td>A Signer that attaches an electronic signature to an OOXML document.</td>
                    </tr>
                    <tr>
                        <td>Archiver</td>
                        <td>
Implementation handling archiving of a worker's response by storing it in a database or similar.
                        </td>
                    </tr>
                </table>
            </section>

            <section name="Overall Architecture">
                    <p>
The SignServer is a framework designed to perform different kind of cryptographic operations for different applications.
                    </p>
                    <p>
Since the 3.0 version there are three kind of processable services. Signers (used to sign or in other way  process requested data). Validation Services used to verify the validity of a certificate against a set of backed issuers. The validation service can be used to simply the integration of PKIs into existing applications. The the third processable service is a group key service framework used to manage and to distribute group keys for different applications, these keys can be both symmetric and asymmetric. In addition to processable services there also exists another concept called Timed Service (called just 'service' in 2.0 edition) which are plug-ins run at defined intervals performing maintenance or reporting routines.
                    </p>
                    <p>
Out-of-the-box are there three Signers ready to be used. They are a MRTD Signer used for signing Machine Readable Travel Documents (also known as Electronic Passports), a Timestamp Signer that can be used to set up a Timestamp Authority and a PDF signer that can be used to automatically sign documents.
                    </p>
                    <p>
The main way of communicating with the SignServer is through a WebService interface (previous versions had a RMI-SSL interface, but that have been replaced by the WS for better platform independence.) but the Timestamp Signer is also available through HTTP communication and the PDF signer have a simple HTML page that allows users to upload documents to be signed.
                    </p>
                    <p>
For an overview of the different concepts in the SignServer see illustration 1. The base component is called Worker which is assigned an id, optionally a name and a configuration. A sub component is a Processable which receives and processes requests. A Processable (optionally) have access to a cryptographic token (CryptoToken) in charge of managing the keys of a Processable. A CryptoToken can be either software or hardware based.
                    </p>
                    <p>
The applications i administrated through a command-line interface, where the properties and access control can be configured.
                    </p>
                    <p>
One SignServer can have multiple services for different purposes.
                    </p>

                    <p>
                        <a href="../docs/SignServer_Manual_3_0_odt_18c42972.png"><img src="../docs/SignServer_Manual_3_0_odt_18c42972.png" align="middle" border="0" width="493" height="252" alt="SignServer components"/></a><br/>
                        Illustration 1: Components in the SignServer project
                    </p>
            </section>

        </chapter>

        <chapter name="Installation Guide" shortname="installguide">

            <section name="Server installation">
                <subsection name="1. Check prerequisites">
                    <p>
Make sure all required softwares are installed:
                    </p>
                    <ul>
                        <li>Java: Sun/Oracle JDK 6 Update 10 or later or OpenJDK*</li>
                        <li>Application server: JBoss 4.2.3.GA**, JBoss 5.1.0.GA or GlassFish Server Open Source Edition 2.1.1</li>
                        <li>Database: HypersonicSQL (bundled with JBoss), MySQL 5.1 or Oracle Database 10/11g</li>
                        <li>Build tool: Apache Ant 1.7.1 or later</li>
                    </ul>
                    <p>
* The ODFSigner has issues with OpenJDK. Please see <a href="https://jira.primekey.se/browse/DSS-168">DSS-168</a> for a workaround.<br/>
** JBoss 4.2.3.GA is available in two different versions (standard and JDK6) which differens in web services stacks. The one called JBoss 4.2.3.GA-JDK6 should be used.
                    </p>
                </subsection>

                <subsection name="2. Unpack SignServer">
                    <p>
Download and unzip the
<a href="http://sourceforge.net/projects/signserver/files/signserver/">latest
SignServer release</a> archive from SourceForge or for the absolutely latest
unstable version checkout from the Subversion (SVN)
<a href="http://sourceforge.net/projects/signserver/develop">repository</a>.
                    </p>
                </subsection>

                <subsection name="3. Set environment variables">
                    <subsubsection name="APPSRV_HOME">
                        <p>
Set APPSRV_HOME to point to your application server installation.
                        </p>
                        <source>
export APPSRV_HOME=/opt/jboss-4.2.3.GA
                        </source>
                    </subsubsection>
                    <subsubsection name="ANT_OPTS">
                        <p>
Set ANT_OPTS to give Ant more memory for building SignServer.
                        </p>
                        <source>
export ANT_OPTS="-Xmx512m -XX:MaxPermSize=128m"
                        </source>
                    </subsubsection>
                    <subsubsection name="SIGNSERVER_HOME">
                        <p>
Set SIGNSERVER_HOME to point to your SignServer installation.
                        </p>
                        <source>
export SIGNSERVER_HOME=/opt/signserver
                        </source>
                    </subsubsection>
                    <subsubsection name="SIGNSERVER_NODEID">
                        <p>
Set SIGNSERVER_NODEID to an unique ID for the server.
                        </p>
                        <source>
export SIGNSERVER_NODEID=node1
                        </source>
                    </subsubsection>
                </subsection>

                <subsection name="4. Setup database">
                    <p>
Create a database and user for SignServer. The application server will try to
create tables during startup of SignServer but if the database user does not
have table create permissions or if you run on GlassFish the tables must be
created manually. See doc/howtos/create-tables-signserver32-*.sql.
                    </p>
                    <p>
Copy the driver for your database to the application server lib folder.
                    </p>
                    <p>
For GlassFish also configure a connection pool and JNDI resource:
                    </p>
                    <ol>
                        <li>Go to the Admin Console: http://localhost:4848</li>
                        <li>Click on Resources -&gt; JDBC -&gt; Connection Pools</li>
                        <li>Add a new Pool. For instance: Name: MySQLPool</li>
                        <li>
                            Fill in:<br/>
                            databaseName: signserver<br/>
                            password: signserver<br/>
                            portNumber 3306<br/>
                            serverName: localhost<br/>
                            user: signserver
                        </li>
                        <li>Click Ping to test</li>
                        <li>Click on Resources -&gt; JDBC -&gt; JDBC Resources</li>
                        <li>
                             Add new:<br/>
                             JNDI Name: jdbc/SignServerDS<br/>
                             Pool Name: MySQLPool
                         </li>
                        <ul></ul>
                    </ol>
                </subsection>

                <subsection name="4. Configure web server keystores">
                    <p>
For JBoss if you are going to protect the HTTP communication with SSL, you need
a JKS SSL server keystore. Rename the web server keystore to tomcat.jks at put
it in a 'p12' subdirectory. Also place the web server root certificate in DER
encoding in the same directory, call it rootcert.cer.
                    </p>
                    <p>
For GlassFish enable client authentication for http-listener-2 and manually
update the keystores with the right certificates.
                    </p>
                </subsection>

                <subsection name="5. Configure application server">
                    <subsubsection name="Fix web service problem in JBoss">
                        <p>
Edit jboss-beans.xml to force the endpoint URL to be generated based on the WSDL
request by commenting out the line:
                        </p>
<pre>
    &lt;property name="webServiceHost"&gt;${jboss.bind.address}&lt;/property&gt;
</pre>
                        <p>
For JBoss 4.2.3.GA the file is available under: server/default/deploy/jbossws.sar/jbossws.beans/META-INF/
                        </p>
                        <p>
For JBoss 5.1.0.GA the file is available under: server/default/deployers/jbossws.deployer/META-INF/
                        </p>
                    </subsubsection>
                    <subsubsection name="Fix JBoss 5 bug with Oracle JDK">
                        <p>
If you are using Oracle's JDK and JBoss 5.1.x you need to copy
SIGNSERVER_HOME/lib/1.6/bc*.jar to JBOSS_HOME/server/default/lib/. Remember this
when it's time for upgrades! This is a bug tracked by JBoss as JBAS-7882.
                        </p>
                    </subsubsection>
                </subsection>


                <subsection name="6. Configure build">
                    <p>
Copy conf/signserver_build.properties.sample to conf/signserver_build.properties and open
it for editing in your favorite text editor.
                    </p>
                    <source>
cp conf/signserver_build.properties.sample conf/signserver_build.properties
                    </source>

                    <subsubsection name="Application server configuration">
                        <p>
Set appserver.type to the application server (jboss or glassfish).
                        </p>
                        <source>
appserver.type=jboss
                        </source>
                    </subsubsection>

                    <subsubsection name="Web GUI configuration">
                        <p>
Uncomment j2ee.web-nohttps=true if SignServer should be used to configure the
keystore in JBoss.
                        </p>
                        <source>
#j2ee.web-nohttps=true
                        </source>
                        <p>
For GlassFish change httpserver.privhttps to a port configured with HTTPS and
client authentication.
                        </p>
                        <source>
httpserver.privhttps=8181
                        </source>
                    </subsubsection>

                    <subsubsection name="Database configuration">
                        <p>
For GlassFish make sure the datasource.jndi-name and datasource.jndi-name-prefix
matches the resource configured in the admin console.
                        </p>
                        <source>
datasource.jndi-name=SignServerDS
datasource.jndi-name-prefix=jdbc/
                        </source>
                        <p>
Select database management system
                        </p>
                        <source>
database.name=mysql
                        </source>

                        <p>
For JBoss set the database connection URL, database driver and username and
password.
                        </p>
                        <source>
database.url=jdbc:mysql://127.0.0.1:3306/signserver
database.driver=com.mysql.jdbc.Driver
database.username=signserver
database.password=signserver
                        </source>
                    </subsubsection>

                    <subsubsection name="Web Service Configuration">
                        <p>
Enable or disable the web services.
                        </p>
                        <source>
signserverws.enabled=true
genericws.enabled=true
validationws.enabled=true
adminws.enabled=true
                        </source>
                    </subsubsection>

                    <subsubsection name="Modules Configuration">
                        <p>
Enable all modules that should be built and choose if they should be included in the SignServer enterprise application archive (EAR). By setting includemodulesinbuild=true (default) all modules are built in. Otherwise for each module specify that it should be enabled and included:
                        </p>
                        <source>
module.xmlsigner.enabled=true
module.xmlsigner.include=true
...
                        </source>
                        <p>
For GlassFish to enable debug logging include the Log4j module.
                        </p>
                        <source>
module.log4j.enabled=true
module.log4j.include=true
                        </source>
                    </subsubsection>

                </subsection>

                <subsection name="7. Build and deploy SignServer">
                    <p>
Run "ant deploy" to build SignServer and deploy it to the selected application
server. If the configuration changed since the last build run the clean target
first.
                    </p>
                    <source>
bin/ant clean build deploy
                    </source>
                    <p>
Start the application server and verify that SignServer was deployed and
database tables were created. 
                    </p>
				</subsection>
				<subsection name="8. Accessing SignServer">
					<p>
After startup a few different user interfaces are available.	
					</p>
					<subsubsection name="Command Line Interface">
                    <source>
bin/signserver getstatus brief all
Assuming JBoss JNDI provider...
===========================================
Executing Command on host : localhost
===========================================


Current version of server is : SignServer 3.3.0alpha0
                    </source>
					</subsubsection>
					<subsubsection name="Graphical User Interface">
						<source>
bin/signserver-gui	
						</source>
					</subsubsection>
					<subsubsection name="Web Interface">
					<p>
Point your web browser to <a href="http://localhost:8080/signserver">http://localhost:8080/signserver</a> for demo web pages and local documentation.
					</p>
					</subsubsection>
                </subsection>
            </section>

            <section name="Signer setup">
                <p>
After server installation the different signers can be setup using the
SignServer CLI.
                </p>
                <subsection name="Loading signers">
                    <p>
Signers (and other workers) can be loaded by setting properties using "setproperty" or "setproperties" etc.
                    </p>
                    <subsubsection name="setproperties">
                        <p>
The "setproperties" command loads all the properties from a property file that
can define one or many signers. The code for the signers needs to be deployed
to the application server together with SignServer either by setting
includemodulesinbuild=true to include all modules or by setting individual
module.MODULENAME.include=true properties in signserver_build.properties.
                        </p>
                        <source>
bin/signserver setproperties doc/sample-configs/CONFIGURATION.PROPERTIES
                        </source>
                    </subsubsection>
                    <p>
After adding or changing a property for a worker (by
any of the "setpropery" or "setproperties" commands) the configuration needs be
applied by issuing the reload command with the ID of the worker.
                    </p>
                    <source>
bin/signserver reload 4711
                    </source>
                </subsection>

                <subsection name="Quick start demo Timestamp signer">
                    <p>
This is a quick start guide to quickly get you setup with a demo Time Stamp service (TSA according to RFC3161). It will let you quickly get a feeling how the structure of the SignServer works, so you can move on to more advanced features described in the manual.
                    </p>

                    <ol>
                        <li>
Make sure the tsa module is built in by setting module.tsa.enabled=true and
module.tsa.include=true in signserver_build.properties before building and
deploying SignServer. Alternativly, set includemodulesinbuild=true to have all
modules built in.
                        </li>
                        <li>
Load the Timestamp demo configuration and notice the generated worker ID (in this
example 1):<br/>
<code>$ bin/signserver setproperties doc/sample-configs/qs_timestamp_configuration.properties</code>
                        </li>
                        <li>
Activate the configuration with:<br/>
<code>$ bin/signserver reload 1</code>
                        </li>
                        <li>
You can check the status and configuration with:<br/>
<code>$ bin/signserver getstatus complete all</code>
                        </li>
                        <li>
Run the test client to see that everything is up:<br/>
<code>$ bin/signclient timestamp http://localhost:8080/signserver/process?workerName=TimeStampSigner</code>
<br/>The message "TimeStampRequest validated" should appear once a second. Also
check JBOSS_HOME/server/default/log/server.log or
GLASSFISH_HOME/domains/domain1/logs/server.log that successful messages appear.
                        </li>
                    </ol>
                </subsection>

                <subsection name="Quick start demo PDF signer">
                    <p>
To install the PDF signer you can issue the following commands (either instead of the TSA or in addition to the TSA).
                    </p>
                    <ol>
                        <li>
Make sure the pdfsigner module is built in by setting module.pdfsigner.enabled=true and
module.pdfsigner.include=true in signserver_build.properties before building and
deploying SignServer. Alternativly, set includemodulesinbuild=true to have all
modules built in.
                        </li>
                        <li>
Load the PDF signer demo configuration and notice the generated worker ID (in this
example 2):<br/>
<code>$ bin/signserver setproperties doc/sample-configs/qs_pdfsigner_configuration.properties</code>
                        </li>
                        <li>
Activate the configuration with:<br/>
<code>$ bin/signserver reload 2</code>
                        </li>
                        <li>
You can check the status and configuration with:<br/>
<code>$ bin/signserver getstatus complete all</code>
                        </li>
</ol>
<p>
You can now, with your web browser, access the URL <a href="http://localhost:8080/signserver/demo/pdfsign.jsp">http://localhost:8080/signserver/demo/pdfsign.jsp</a> to get PDF documents signed.
</p>
</subsection>

                <subsection name="Quick start demo OOXML signer">
                    <p>
To install the OOXML signer you can issue the following commands.
                    </p>
                    <ol>
                        <li>
Make sure the ooxmlsigner module is built in by setting module.ooxmlsigner.enabled=true and
module.ooxmlsigner.include=true in signserver_build.properties before building and
deploying SignServer. Alternativly, set includemodulesinbuild=true to have all
modules built in.
                        </li>
                        <li>
Load the OOXML signer demo configuration and notice the generated worker ID (in this
example 3):<br/>
<code>$ bin/signserver setproperties doc/sample-configs/qs_ooxmlsigner_configuration.properties</code>
                        </li>
                        <li>
Activate the configuration with:<br/>
<code>$ bin/signserver reload 3</code>
                        </li>
                        <li>
You can check the status and configuration with:<br/>
<code>$ bin/signserver getstatus complete all</code>
                        </li>
                    </ol>
<p>
You can now, with your web browser, access the URL <a href="http://localhost:8080/signserver/demo/ooxmlsign.jsp">http://localhost:8080/signserver/demo/ooxmlsign.jsp</a> to get any Office Open XML documents signed (ex: MS Office 2007 Word document, Excel document, Power Point presentation...).
</p>
</subsection>

                <subsection name="Quick start demo ODF signer">
                    <p>
To install the ODF signer you can issue the following commands.
                    </p>
                    <ol>
                        <li>
Make sure the odfsigner module is built in by setting module.odfsigner.enabled=true and
module.odfsigner.include=true in signserver_build.properties before building and
deploying SignServer. Alternativly, set includemodulesinbuild=true to have all
modules built in.
                        </li>
                        <li>
Load the ODF signer demo configuration and notice the generated worker ID (in this
example 4):<br/>
<code>$ bin/signserver setproperties doc/sample-configs/qs_odfsigner_configuration.properties</code>
                        </li>
                        <li>
Activate the configuration with:<br/>
<code>$ bin/signserver reload 4</code>
                        </li>
                        <li>
You can check the status and configuration with:<br/>
<code>$ bin/signserver getstatus complete all</code>
                        </li>
                    </ol>
                    <p>
You can now, with your web browser, access the URL <a href="http://localhost:8080/signserver/demo/odfsign.jsp">http://localhost:8080/signserver/demo/odfsigner.jsp</a> to get any Open Document Format documents signed (ex: documents produced by OpenOffice.org or LibreOffice).
                    </p>
                </subsection>


                <subsection name="Quick start demo XML signer">
                    <p>
To install the demo XML signer you can issue the following commands.
                    </p>
                    <ol>
                        <li>
Make sure the xmlsigner module is built in by setting module.xmlsigner.enabled=true and
module.xmlsigner.include=true in signserver_build.properties before building and
deploying SignServer. Alternativly, set includemodulesinbuild=true to have all
modules built in.
                        </li>
                        <li>
Load the XML signer demo configuration and notice the generated worker ID (in this
example 5):<br/>
<code>$ bin/signserver setproperties doc/sample-configs/qs_xmlsigner_configuration.properties</code>
                        </li>
                        <li>
Activate the configuration with:<br/>
<code># bin/signserver reload 5</code>
<br/>
                        </li>
                        <li>
You can check the status and configuration with:<br/>
<code>$ bin/signserver getstatus complete all</code>
                        </li>
                    </ol>
                    <p>
You can now, with your web browser, access the URL <a href="http://localhost:8080/signserver/demo/xmlsign.jsp">http://localhost:8080/signserver/demo/xmlsign.jsp</a> to get XML documents signed.
                    </p>
                </subsection>

                <subsection name="Quick start demo XML validator">
                    <p>
An XML validator validates the signature of an XML document. It uses a
certificate validation service worker for validating the certificate so
that worker has to be configured first.
                    </p>
                    <p>
To install a certificate validation service worker issue the following commands:
                    </p>
                    <ol>
                        <li>
Load the configuration and notice the worker ID (in this example: 6):<br/>
<code>$ bin/signserver setproperties doc/sample-configs/qs_validator_dummy_configuration.properties</code>
                        </li>
                        <li>
Activate the configuration with:<br/>
<code>$ bin/signserver reload 6</code>
<br/>
                        </li>
                        <li>
The status of the Worker can now be viewed with:<br/>
<code>$ bin/signserver getstatus complete CertValidationWorker</code>
<br/>
                        </li>
                    </ol>
                    <p>
Then to install the XML validator you can issue the following commands:
                    </p>
                    <ol>
                        <li>
Make sure the xmlvalidator module is built in by setting module.xmlvalidator.enabled=true and
module.xmlvalidator.include=true in signserver_build.properties before building and
deploying SignServer. Alternativly, set includemodulesinbuild=true to have all
modules built in.
                        </li>
                        <li>
Load the XML validator demo configuration and notice the generated worker ID (in this
example 7):
<br/>$ bin/signserver setproperties doc/sample-configs/qs_xmlvalidator_configuration.properties
                        </li>
                    <li>
Verify the configuration with (notice that VALIDATIONSERVICEWORKER is set to "CertValidationWorker"):<br/>
<code>$ bin/signserver getconfig 7</code>
<br/>
                    </li>
                    <li>
Activate the configuration with:<br/>
<code>$ bin/signserver reload 7</code>
<br/>
                    </li>
                    <li>
The status of the Validator can now be viewed with:<br/>
<code>$ bin/signserver getstatus complete DemoXMLValidator</code>
<br/>
                    </li>
                    </ol>
                    <p>
Now <a href="integration.html">the SignServer APIs</a> can be used to request XML documents to be validated by the DemoXMLValidator worker.
                    </p>
                </subsection>

                <subsection name="Quick start demo MRTD SOD signer">
                    <p>
The MRTD SOD signer takes as input data group hashes and creates a signed SO(d). This means that the signserver will function
as a Document Signer for ePassports.</p>
                    <p>
To install the MRTD SOD signer you can issue the following commands:
                    </p>
                    <ol>
                        <li>
Make sure the mrtdsodsigner module is built in by setting module.mrtdsodsigner.enabled=true and
module.mrtdsodsigner.include=true in signserver_build.properties before building and
deploying SignServer. Alternativly, set includemodulesinbuild=true to have all
modules built in.
                        </li>
                        <li>
Load the MRTD SOD signer demo configuration and notice the generated worker ID (in this
example 8):<br/>
<code>$ bin/signserver setproperties doc/sample-configs/qs_mrtdsodsigner_configuration.properties</code>
                        </li>
                        <li>
Activate the configuration with:<br/>
<code>$ bin/signserver reload 8</code><br/>
                        </li>
                        <li>
The status of the signer can now be viewed with:<br/>
<code>$ bin/signserver getstatus complete mrtdsodsigner</code><br/>
                        </li>
                    </ol>
                    <p>
Now <a href="integration.html">the SignServer APIs</a> can be used to send MRTD SOD sign requests the MRTDSODSigner.
<br/>
Also you can use the HTML page <a href="http://localhost:8080/signserver/demo/mrtdsodsign.jsp">http://localhost:8080/signserver/demo/mrtdsodsign.jsp</a> to enter requests and get the SOd back.
This HTML form also functions as a sample to show how you can make HTTP requests from the personalisation system to the Document Signer.
                    </p>
                    <subsubsection name="Production configuration with HSM">
                        <p>
To install a production signer using an HSM instead of the demo signer you can
edit doc/sample-config/qs_mrtdsodsigner_configuration.properties and change from
SoftCryptoToken to PKCS11CryptoToken and comment all properties under
SoftCryptoToken properties and instead fill in all properties under
PKCS11CryptoToken properties and then run:
<br/>(note after changing properties in the file it needs to be loaded again
with setproperties)
                        </p>
                        <p>
Before starting with an HSM installation you should read the about the
<a href="plugins.html#PKCS11CryptoToken">PKCS11CryptoToken</a> in the plugins
section of the manual.
                        </p>
<source>
bin/signserver setproperties doc/sample-config/qs_mrtdsodsigner_configuration.properties
bin/signserver getconfig 9
bin/signserver reload 9
bin/signserver generatecertreq 9 "C=SE,CN=MRTD SOD Signer" SHA256WithRSA mrtdsodsigner.req
</source>
                        <p>
Where 9 is the signerId that you got when running the 'setproperties' command.<br/>
This will create a certificate request that you can get signed by your CA. When you have received the response you can import it and the CA certficate.
If you have the returned signer certificate as cert.pem and the CA certificate as cacert.pem, then:
                        </p>
<source>
cat cert.pem cacert.pem &gt; certchain.pem
bin/signserver uploadsignercertificate 9 glob cert.pem
bin/signserver uploadsignercertificatechain 9 glob certchain.pem
bin/signserver reload 9
</source>
                        <p>
Hint: you can use EJBCA to create keys on a PKCS#11 HSM using clientToolBox.<br/>
ejbcaClientToolBox.sh PKCS11HSMKeyTool generate /opt/ETcpsdk/lib/linux-x86_64/libcryptoki.so 2048 DSSignKey 5
                        </p>
                    </subsubsection>
            </subsection>

            </section>

            <section name="Historic Installation Guides">
                <subsection name="Clustered SignServer 3.0 CentOS 4.4 Installation Guide">
                    <p>
Installation guide describing step-by-step how to setup a SignServer cluster on CentOS 4.4. Even if the document
is specific for this OS is should be quite easy to adopt it to other environments as well. It 
can be downloaded here either as <a href="../docs/SignServer_3_0_Installation_Guide.pdf">PDF</a> or viewed as
<a href="../docs/SignServer_3_0_Installation_Guide.html">HTML</a>
                    </p>
                </subsection>
                <subsection name="Clustered SignServer 2.0 CentOS 4.4 Installation Guide">
                    <p>
Version 2.0 of the same documentation.<a href="../docs/SignServer_2_0_Installation_Guide.pdf">PDF</a> <a href="../docs/SignServer_2_0_Installation_Guide.html">HTML</a>
                    </p>
                </subsection>
            </section>
        </chapter>

        <chapter name="Usage Guide" shortname="usageguide">
            <section name="Introduction">
                <p>   
                </p>
            </section>

            <section name="Configuration/Administration">
                <p>
The SignServer administration command line interface (Admin CLI) is started
using bin/signserver (or bin/signserver.cmd).
                </p>
                <p>
Every worker is identified by an ID and an optional name that can be used in all
the CLI commands.
                </p>
                <p>
It is possible to do configuration of a worker while it's in production. All
configuration commands are cached until a reload command is issued and the
configuration becomes active.
                </p>
                <p>
There is a special property file for the cli interface called signserver_cli.properties defining which nodes that exists in the cluster. The properties are:
                </p>
                <p>
<b>hostname.masternode</b> = Should only contain one of the nodes, specified as the default master node. Used by operations dealing with the database and where not all nodes in the cluster needs to be contacted. It is possible to override this setting in the CLI by using the -host &lt;host name&gt; parameter.
                </p>
                <p>
<b>hostname.allnodes</b> = Should contain all the nodes in the cluster, separated by a ';'. Mainly used by the commands getStatus, activateCryptoToken and deactivateCryptoToken.
                </p>
                <p>
Its possible to customize the CLI with your own code. How to do this is described in the development section.
                </p>
                <subsection name="Administration CLI">
                    <subsubsection name="General Commands">
                        <p>
<b>getstatus:</b>
Returns the status of the given worker, it says if its crypto token is active or not and the loaded 'active' configuration. It is possible to get a <i>brief</i> summary or a <i>complete</i> listing for one worker or all configured workers. If all workers are displayed will also all the global configuration parameters be displayed.
                        </p>
                        <p>
<b>getconfig:</b>
Returns the current worker or global configuration depending on options.
                        </p>
                        <p>
For worker configuration observe that this configuration might not have been activated yet, not until a <i>reload</i> command is issued.
                        </p>
                        <p>
<b>setproperty:</b>
Sets a custom property used by the worker or crypto token, see reference for the given Worker and CryptoToken for available properties.
                        </p>
                        <p>
<b>setproperties:</b>
Command used to batch a set of properties, both for the global and worker configuration.
It can be used to configure a Signer in a test environment, dump all the properties and upload it into production.
                        </p>
                        <p>
It reads all the configuration properties form a property file and depending on the contents of the key it sets the given property. All properties will be set  according to the following defined rule set.
                        </p>
                        <table>
                            <tr>
                                <th>Rule</th>
                                <th>Comment</th>
                            </tr>
                            <tr>
                                <td>
Properties starting with id&lt;num&gt;.
                                </td>
                                <td>
Will set the property to the value of the given id to the worker with the given id.
                                </td>
                            </tr>
                            <tr>
                                <td>
Properties starting with name&lt;name&gt;.
                                </td>
                                <td>
Will set the property to a worker with the given name. (If the name doesn't exists a unique id will be generated and assigned).
                                </td>
                            </tr>
                            <tr>
                                <td>
Property keys containing GENID&lt;NUM&gt;, example WORKERGENID1 or GLOB. WORKERGENID1
                                </td>
                                <td>
The SignServer will find a free unique id and assign substitute all GENID&lt;num&gt; with this id.
                                </td>
                            </tr>
                            <tr>
                                <td>
Properties starting with glob.
                                </td>
                                <td>
Will set a global property with global scope.
                                </td>
                            </tr>
                            <tr>
                                <td>
Properties starting with node.
                                </td>
                                <td>
Will set a global property with node scope.
                                </td>
                           </tr>
                            <tr>
                                <td>
Properties starting with -&lt;other prefix&gt;&lt;value&gt;
                                </td>
                                <td>
Will remove the property, either worker or global.
                                </td>
                            </tr>
                        </table>
                        <p>
See the directory 'sample-configs' for examples.
                        </p>
                        <p>
<b>removeproperty:</b>
Removes a configured property
                        </p>
                        <p>
<b>dumpproperties:</b>
This tool will dump all configured properties for one or all workers in the system into a property file. If the configuration for one worker is dumped it can be used to transfer the configuration from one installation to another. If all configurations is dumped, it can be used as a backup tool.
                        </p>
                        <p>
<b>uploadsignercertificate:</b>
Used to upload the certificate when the worker only needs the actual signing certificate and not the entire chain.
                        </p>
                        <p>
<b>uploadsignercertificatechain:</b>
Used when uploading a complete certificate chain to the worker. Which command that is supposed to be used is depending on the worker and crypto token used.
                        </p>
                        <p>
<b>generatecertreq:</b>
Used to generate a certificate request for a worker to be signed by a certificate authority. It takes
distinguished name and signature algorithm as parameters and writes the request in PEM format to
file.
                        </p>
                        <p>
<b>activatecryptotoken:</b>
Used to activate crypto tokens. Authentication code is usually the PIN used to unlock the keys on the HSM. Not used if the token is set to auto-activation.
                        </p>
                        <p>
<b>deactivatecryptotoken:</b>
Brings a crypto token off-line. Not used if token is set to auto-activation.
                        </p>
                    </subsubsection>

                    <subsubsection name="SignServer Specific Commands">
                        <p><b>Authorization Related</b></p>
                        <p>
These commands are used to configure the internal client certificate authorization when it is turned on. It controls which clients that is authorized to request a processable worker.
                        </p>
                        <p>
<b>addauthorizedclient:</b>
Adds a client certificate to a processable workers list of acceptable clients using this worker. Specify
certificate serial number in hex and the Issuer DN of the client certificate.
                        </p>
                        <p>
<b>removeauthorizedclient:</b>
Removes added client certificate entries.
                        </p>
                        <p>
<b>listauthorizedclients:</b>
Displays the current list of acceptable clients.
                        </p>

                        <p><b>Database Related</b></p>
                        <p>
<b>resync:</b>
                        </p>
                        <p>
The 'resync' command is used after a SignServer had a complete database failure. When this happens  will the Global Configuration become in 'Off-line' mode and it's not possible for the nodes to communicate internally and the Global Configurations will not be in sync any more. After the database is up again can this command be sent to the node that have the most valid Global Configuration and write it to the database. After this will the Global Configuration be in 'On-line' mode again.
                        </p>

                        <p><b>Archive Related</b></p>
                        <p>
This commands can be used for processable workers that have archiving turned on. They 
are used to find specific archived responses. It's up to the implementation of the 
worker if it supports archiving or not and it is up to the choosen Archiver if it 
archives the data in way that it can be queried using this commands. For Archivers 
other than the default "OldDatabaseArchiver" quering might have to be done 
directly in the database or by some custom application.
                        </p>
                        <p>
<b>archive findfromarchiveid:</b>
Command used to extract archived data from database identified by the archive Id.
                        </p>
                        <p>
The Id depends on the worker, in case of the TSA is the TimeStampInfo serial number used.
The data is stored with the same file name as the archive id in the specified path.
                        </p>
                        <p>
<b>archive findfromrequestip:</b>
Used to extract all archived data requested from a specified IP address.
                        </p>
                        <p>
All data is stored as separate files with the archive id as file name in the specified path.
                        </p>
                        <p>
<b>archive findfromrequestcert:</b>
Used to extract all archived data requested from a client by specified it's certificates serial number and  issuer DN.
                        </p>
                        <p>
All data is stored as separate files with the archive id as file name in the specified path.
                        </p>

                        <p><b>Group Key Service Related</b></p>
                        <p>
These commands only applies for group key services.
                        </p>
                        <p>
<b>groupkeyservice pregeneratekeys:</b>
Command used to pregenerate a given number of group keys for a given group key service and stores them unassigned encrypted in the database. This commands can be used to let the cluster work on CPU insensitive key generation during low business hours.
                        </p>
                        <p>
<b>groupkeyservice removegroupkeys:</b>
Command used to remove group keys not used any more. A time range of when created, first used and last fetched can be used as criteria.
                        </p>
                        <p>
<b>groupkeyservice switchenckey:</b>
Command used manually switch the encryption key used to secure the group keys in database. Usually is the encryption key switched automatically but this command can be used to override this default behaviour.
                        </p>

                        <p><b>Administrators Related</b></p>
                        <p>
<b>wsadmins -list:</b>
                        </p>
                        <p>
Lists administrator certificates (certificate serial number and issuer DN) for
administrators authorized to use the Admin Web Service interface to administrate
SignServer.
                        </p>
                        <p>
<b>wsadmins -add:</b>
                        </p>
                        <p>
Authorizes an administrator to use the Admin Web Service interface by
certificate serialnumber and issuer DN.
                        </p>
                        <p>
<b>wsadmins -remove:</b>
                        </p>
                        <p>
Removes an administrator from the list of authorized administrators.
                        </p>
                    </subsubsection>
                </subsection>

                <subsection name="Administration GUI">
                    <p>
As a complement to the command line interface there is also a graphical user
interface for managing some of the most basic administrative tasks.
                    </p>
                    <p>
The SignServer AdminGUI can be build by running "ant admingui" and then started 
using the script bin/admingui.sh. By default it tries to connect to a locally
running SignServer instance using EJB calls. If that fails or if the command
line option "-ws" is specified a connection dialog for connecting using web
services is displayed instead.
                    </p>
                    <subsubsection name="Connect to SignServer dialog">
                        <p>
Specify URL to SignServer server as well as keystore and truststore for setting
up the HTTPS connection and then click the button <b>Connect</b>. By clicking
the button <b>Load defaults</b> the settings from the file
default_connect.properties is loaded. If the connection is successful the
current settings are stored to connect.properties and displayed the next time
the dialog is openned.
                        </p>
                        <p>
<b>Web Service URL</b>: Base URL to the SignServer server. Default: https://localhost:8443/signserver
                        </p>
                        <p>
<b>Truststore Type</b>: Type of the truststore. Should match the choosen
truststore file (if any). Options are: "Use keystore", JKS, PKCS12 or PEM. If
"Use keystore" is choosen the trusted certificates are instead taken from the
keystore and no truststore is used.
                        </p>
                        <p>
<b>Truststore file path</b>: Path to the truststore file (if any).
                        </p>
                        <p>
<b>Truststore password</b>: Password of the truststore file (if any).
                        </p>
                        <p>
<b>Keystore Type</b>: Type of the keystore. Should match the choosen keystore file
path. Options are: JKS, PKCS12 or PKCS11. If PKCS11 is choosen the keystore file
path should be the patch to the PKCS#11 shared library file.
                        </p>
                    </subsubsection>

                    <subsubsection name="Main window">
                        <p>
The SignServer Administration GUI main window consists of a menu bar, a toolbar,
the working area and at the bottom a status bar. The working area constists of a
left and right part where the left is a list of all configured workers and the
right shows details for the selected workers (if any).
                        </p>
                    </subsubsection>

                    <subsubsection name="Main window: Menu bar">
                        <p>
<b> File -&gt; Exit</b>: Exits the SignServer Administration GUI
                        </p>
                        <p>
<b> Edit -&gt; Activate</b>: Activates the selected worker(s).
                        </p>
                        <p>
<b> Edit -&gt; deactivate</b>: Deactivates the selected worker(s).
                        </p>
                        <p>
<b> Edit -&gt; Renew key...</b>: Opens the Renew key dialog for the selected worker(s).
                        </p>
                        <p>
<b> Edit -&gt; Test key...</b>: Opens the Test key dialog for the selected worker(s).
                        </p>
                        <p>
<b> Edit -&gt; Generate CSR...</b>: Opens the Generate CSR dialog for the selected worker(s).
                        </p>
                        <p>
<b> Edit -&gt; Install certificates...</b>: Opens the Install certificates dialog for the selected worker(s).
                        </p>
                        <p>
<b> Edit -&gt; Renew signer...</b>: Opens the Renew signer dialog for the selected worker(s).
                        </p>
                        <p>
<b> Edit -&gt; Global configuration...</b>: Opens the Global configuration window.
                        </p>
                        <p>
<b> Edit -&gt; Administrators...</b>: Opens the Administrators window.
                        </p>
                        <p>
<b> View -&gt; Refresh</b>: Refreshes the information about all workers.
                        </p>
                        <p>
<b> View -&gt; Status Summary...</b>: Switches to the Status Summary tab for the selected worker.
                        </p>
                        <p>
<b> View -&gt; Status Properties...</b>: Switches to the Status Properties tab for the selected worker.
                        </p>
                        <p>
<b> View -&gt; Configuration...</b>: Switches to the Configuration tab for the selected worker.
                        </p>
                        <p>
<b> View -&gt; Authorization...</b>: Switches to the Authorization tab for the selected worker.
                        </p>
                        <p>
<b> Help -&gt; About...</b>: Opens the about box doc.
                        </p>
                    </subsubsection>

                    <subsubsection name="Main window: Tool bar">
                        <p>
<b>Refresh</b>: Refreshes the information about all workers.
                        </p>
                        <p>
<b>Activate</b>: Activates the selected worker(s).
                        </p>
                        <p>
<b>Deactivate</b>: Deactivates the selected worker(s).
                        </p>
                        <p>
<b>Renew key...</b>: Opens the Renew key dialog for the selected worker(s).
                        </p>
                        <p>
<b>Test key...</b>: Opens the Test key dialog for the selected worker(s).
                        </p>
                        <p>
<b>Generate CSR...</b>: Opens the Generate CSR dialog for the selected worker(s).
                        </p>
                        <p>
<b>Install certificates...</b>: Opens the Install certificates dialog for the selected worker(s).
                        </p>
                        <p>
<b>Renew signer...</b>: Opens the Renew signer dialog for the selected worker(s).
                        </p>
                    </subsubsection>

                    <subsubsection name="Main window: Status Summary Tab">
                        <p>
Displays the status summary for the selected worker in the same format as the
CLI command "signserver getstatus complete".
                        </p>
                    </subsubsection>

                    <subsubsection name="Main window: Status Properties Tab">
                        <p>
Displays the status in properties format with the option of viewing details
for some properties such as for the certificates.
                        </p>
                        <p>
<b>Details...</b>: Selecting an property and clicking this button opens a dialog box
with more information for the property (if supported). Currently for certificates
this openns the Certificate details dialog.
                        </p>
                    </subsubsection>

                    <subsubsection name="Main window: Configuration Tab">
                        <p>
Lists all the selected worker's configuration properties and gives the ability
to add, remove or edit properties.
                        </p>
                        <p>
<b>Add...</b>: Adds a new property to the selected worker.
                        </p>
                        <p>
<b>Edit</b>: Edit the selected property.
                        </p>
                        <p>
<b>Remove</b>: Removes the selected property.
                        </p>
                    </subsubsection>

                    <subsubsection name="Main window: Authorization Tab">
                        <p>
Lists all the authorized client certificates for the selected worker. Notice 
that this only applies if the worker has the AUTHTYPE set to CLIENTCERT 
otherwise information about authorized clients might be taken from other sources.
                        </p>
                        <p>
<b>Add...</b>: Adds a new authorized client. If the option 
"Apply changes to all selected workers" is checked the client is added to all 
the currently selected workers.
                        </p>
                        <p>
<b>Edit...</b>: Edits the selected authorized client. If the option 
"Apply changes to all selected workers" is checked the client is modified in all 
the currently selected workers.
                        </p>
                        <p>
<b>Remove</b>: Removes the selected client. If the option
"Apply changes to all selected workers" is checked the client is modified in all
the currently selected workers.
                        </p>
                    </subsubsection>

                    <subsubsection name="Renew key dialog">
                        <p>
Generates new keys for all the listed workers. For this to work all workers should
have the same password. Key algorithm, Key specification and New key alias must
be specified if it is not taken from the worker's configuration.
                        </p>
                    </subsubsection>

                    <subsubsection name="Test key dialog">
                        <p>
Test keys for all the listed workers. It is optional to either test the current
key or the next key (if any) or all the keys in the keystore. For this to work
all workers should have the same password. The results shows for each key the
key alias, SUCCESS and the public key hash if the test signing succeded.
                        </p>
                    </subsubsection>

                    <subsubsection name="Generate CSR dialog">
                        <p>
Generates certificate signing requests (CSR:s) in PKCS#10 format for all listed 
signers and either for the current key (Default key) or the next key. 
Signature algorithm, subject distingueshed name (DN) and Filename must be 
specified if not already taken from the worker's configuration. The format of 
the request could either be a Standard CSR file or a CSR wrapped in PKCS#7/CMS 
signed object created by a RequestSigner. The with the last option is that at 
the CA the signature of the request can be verified.
                        </p>
                    </subsubsection>

                    <subsubsection name="Install certificates">
                        <p>
Installs signer certificate and certificate chains for the listed workers and
if next key is choosen that key becomes the new default key.
                        </p>
                        <p>
<b>Signer certificate</b>: Browse for the signer certificate file in PEM format.
                        </p>
                        <p>
<b>Certificate chain</b>: Browse for the signer certificate chain file in PEM
format. The signer certificate is added to the chain if it is not already
included so normally this could just be the CA certificate.
                        </p>
                    </subsubsection>

                    <subsubsection name="Renew signer dialog">
                        <p>
Requests a Renewal worker to renew all the choosen and selected workers. The 
Renewal worker will generate a new key if there isn't already a next key available 
and then contact EJBCA using its web service interface to request a new certificate.
After recieving the new certificate it is installed and the next key becomes 
the current default key. Notice how the "Not valid after" date and possibly also
the Signings column changes and the Renewal checkbox gets unchecked after a
successfull renewal.
                        </p>
                    </subsubsection>

                    <subsubsection name="Global configuration dialog">
                        <p>
Lists all the global configuration properties and gives the ability to add,
remove or edit properties.
                        </p>
                    </subsubsection>

                    <subsubsection name="Administrators dialog">
                        <p>
Lists all the authorized WS administrators and gives the ability to add,
remove or edit authorized administrators.
                        </p>
                    </subsubsection>

                </subsection>

                <subsection name="Working with Workers">
                    <p>
In SignServer operations are performed by workers. There can be many workers 
and each worker has its own configuration. Each worker is identified by an unique 
ID. A worker can also be configured with a name by setting the property NAME. 
After the configuration has been activated (by issuing reload with the worker ID) 
that name can also be used to address the worker.
                    </p>
                    <subsubsection name="Configuring">
                        <p>
A worker is configured by setting properties for it. Specifically if the plugin
is built-in it is specified by setting the property CLASSPATH to the fully
qualified name of the class implementing the plugin.
                        </p>
                        <p>
The properties can be set manually using the setproperty command or by loading
them all at once from a configuration file using the setproperties command.
Sample configuration files are available in SIGNSERVER_HOME/sample-configs.
                        </p>
                        <p>
To setup a PDFSigner using the quick start configuration file issue the
following command:
                        </p>
                        <source>
bin/signserver setproperties sample-configs/qs_pdfsigner_configuration.properties
                        </source>
                        <p>
Notice the created workerId and use it when applying the configuration using the
reload command:
                        </p>
                        <source>
bin/signserver reload WORKER-ID
                        </source>
                    </subsubsection>
                <subsubsection name="Remove Workers">
                    <p>
                    You can list which workers you have with the command:
                    </p>
                    <source>
bin/signserver getstatus brief all                    
                    </source>
                    <p>
                    If will display for example:
                    </p>
                    <source>
===========================================
Executing Command on host : localhost
===========================================


Current version of server is : SignServer 3.3.0alpha0


Status of Signer with Id 1 is :
  SignToken Status : Offline
  Signings: 0
                    </source>
                    <p>
                    You can remove the worker with Id 1 with the command:                    
					</p>
                    <source>
bin/signserver removeworker 1
bin/signserver reload all                    
                    </source>
                </subsubsection>
            </subsection>
            </section>

            <section name="Making the SignServer highly-available">
                <p>
Here are some tips on configuration used to make the SignServer redundant. Usually is the SignServer set-up with three nodes (required minimum for MySQL cluster) where one node is a management node from were all deployment and administration is done and the other two services are service nodes processing the actual requests.
                </p>
                
                <subsection name="HTTP access requires a load balancer">
                    <p>
HTTP based workers like the TSA can be clustered using a load balancer accessing a health check servlet returning the state of the SignServer. The basic settings of the health check servlet can be configured in the build configuration file but more advanced settings are done in 'src/web/healthcheck/WEB-INF/web.xml'. With the default settings will the servlet return the text 'ALLOK' when accessing the URL http://localhost:8080/signserver/healthcheck/signserverhealth. If something is wrong with the sign server will an error message be sent back instead.
                    </p>
                    <p>
The health check servlet can also be used to monitor the SignServer by creating a script that monitors the URL periodically for error messages.
                    </p>
                    <p>
Tip, heartbeat with ldirectord is a good solution for a load balancer and works well with the SignServer. KeepAlived is another open source solution.
                    </p>
                    <p>
The Main WebService using the Java client API manages the HA parts itself and then isn't a load balancer necessary.
                    </p>
                </subsection>
                <subsection name="Setting up a MySQL Cluster">
                    <p>
The database backed of the SignServer can be made redundant using MySQL Cluster. Details on how to set-up the MySQL cluster can be found in the document <a href="../docs/SignServer_3_0_Installation_Guide.pdf">SignServer_3_0_Installation_Guide.pdf</a> that can be downloaded from <a href="http://www.signserver.org">www.signserver.org</a>.
More information about the MySQL Cluster can be found at
<a href="http://www.mysql.com/products/database/cluster/">http://www.mysql.com/products/database/cluster/</a>.
                    </p>
               </subsection>
            </section>

            
            <!--<section name="Howtos">
                <p>
...
                </p>
            </section>-->
  
        </chapter>

        <chapter name="Integration" shortname="integration">
            <!--<p>
                TODO: Introduction
            </p>-->
            <section name="JavaDoc">
                    <p>
                            The JavaDoc for SignServer is available at SIGNSERVER_HOME/doc/api/index.html
                            after running "ant javadoc".
                    </p>
		</section>

		<section name="Web Services">
                    <p>
New to version 3.0 is the Main WebService interface. It replaces the RMI-SSL interface in version 1.0 and 2.0 for two reasons, the RMI-SSL were based on a commercial library and it only worked for Java clients.
                    </p>
                    <p>
The WebService interface have two calls, the main one is 'process' which takes a collection of process request to a processable worker and returns a collection of process responses, the second one is getStatus that performs a health check of the node and returns an OK message if the node is healthy.
                    </p>
                    <p>
The WebService stack used is JAX-WS and the actual process data is a externalized Base64 byte-arrays. The reason why the are externalized is to simply the integration towards non-Java platforms. See the source of the actual request to see how the data is structured.
                    </p>
                    <p>
The getStatus call can be used to implement high-availability towards the client. The Java client API described in the next section have built in support for different high availability policies.
                    </p>
                    <p>
The WebService WSDL file is located at the URL http://&lt;hostname&gt;:8080/signserver/signserverws/signserverws?wsdl
                    </p>
                    <p>
It's possible to turn off the WebService interface by disabling it in the build configuration.
                    </p>
                    <p>
Since SignServer >=3.2.1 it is possible to supply extra request data called RequestMetadata containing key/value pairs that can be used by the signers. For instance the PDFSigner uses this feature to let the client supply a PDF password. 
                    </p>
		</section>

		<section name="Java Client API">
                    <p>
Built along with the WebService is a Java API that can be used by clients. It's available in the file lib/SignServer-Client-SignServerWS.jar. The client API have support for different high availability policies to avoid the need for load balance hardware.
                    </p>
                    <p>
The client classes is in the package org.signserver.protocol.ws.client and the main code are SignServerWSClientFactory creating a client using the specified load balance policy, it returns a
ISignServerWSClient that is used to perform the actual process requests.
                    </p>
                    
                    <subsection name="Load Balance Policies">
                        <p>
With version 3.0 is one load balance policy defined and it's called 'CallFirstNodeWithStatusOK' it calls the getStatus method on all the server nodes in the cluster simultaneously and the first node to respond OK it sends its process request to. This to ensure that only one node in the cluster actually performs the signing.
                        </p>
                        <p>
Other future load balance policies could be round robin or that all nodes are called with the requests simultaneously and the first response is used.
                        </p>
                    </subsection>
		</section>

		<section name="SigningAndValidation API">
			<p>
				The SigningAndValidation API is a wrapper around the previous
				mentioned API in order to have a simplified interface that also
				is the same regardless if WebService or EJB Remote calls are used.
			</p>
			<p>
				To use the API include the file lib/SignServer-Client-SigningAndValidationAPI.jar.
			</p>
			<subsection name="Sample Code">
				<subsubsection name="Signing and validating an XML document">
                                    <source>
try {
    ISigningAndValidation signserver = new SigningAndValidationWS("localhost", 8080);

    // Document to sign
    byte[] unsigned = "&lt;document&gt;&lt;name&gt;Some content&lt;/name&gt;&lt;/document&gt;".getBytes();
    byte[] signed;

    // Signing
    GenericSignResponse signResp = signserver.sign("DemoXMLSigner", unsigned);
    signed = signResp.getProcessedData();
    System.out.println("Signed: " + new String(signed));

    // Validating
    GenericValidationResponse validateResp = signserver.validate("DemoXMLValidator", signed);
    System.out.println("Valid: " + validateResp.isValid());

    if(validateResp.getSignerCertificate() != null) {
        if(validateResp.getSignerCertificate() instanceof X509Certificate) {
            X509Certificate signerCert = (X509Certificate) validateResp.getSignerCertificate();
            System.out.println("Signed by: " + signerCert.getSubjectDN().getName());
        }
    }
} catch (Exception ex) {
    ex.printStackTrace();
}                                   </source>
				</subsubsection>

				<subsubsection name="MRTD Signing">
                                    <source>
try {
    ISigningAndValidation signserver = new SigningAndValidationWS("localhost", 8080);

    // Bytes to sign
    ArrayList&lt;byte[]&gt; bytesToSign = new ArrayList&lt;byte[]&gt;();
    bytesToSign.add("Sample data 1".getBytes());
    bytesToSign.add("Sample data 2".getBytes());

    // Signing
    MRTDSignResponse signResp = (MRTDSignResponse) signserver.process("MRTDSigner", new MRTDSignRequest(1234, bytesToSign), new RequestContext());

    System.out.println("Certificate: " + signResp.getSignerCertificate());

    if(signResp.getProcessedData() instanceof Collection) {
        Collection&lt;byte[]&gt; signed = (Collection) signResp.getProcessedData();
        for(byte[] data : signed) {
            System.out.println("Signed: " + new String(Base64.encode(data)));
        }
    }
} catch (Exception ex) {
    ex.printStackTrace();
}                               </source>
                            </subsubsection>
			

			</subsection>
		</section>

                <section name="Web Server Interface">
                    <subsection name="GenericProcessServlet">
                        <p>
				HTTP requests can be sent to the SignServer servlet GenericProcessServlet located at /signserver/process using
                                either POST or GET.
			</p>
                        <table>
                            <tr>
                                <td>URL:</td><td><b>/signserver/process</b></td>
                            </tr>
                            <tr>
                                <td>Method:</td><td><b>GET</b> or <b>POST</b></td>
                            </tr>
                            <tr>
                                <td>Request content-type:</td><td><b>None</b>, <b>"x-www-form-urlencoded"</b>, <b>"multipart/form-data"</b> or <b>other<sup>*</sup></b></td>
                            </tr>
                            <tr>
                                <td>Request parameters:</td>
                                <td>
                                    <ul>
                                        <li><b>workerName</b> - Name of the worker that should handle the request. Required unless workerId specified.</li>
                                        <li><b>workerId</b> - Id of the worker that should handle the request. Required unless workerName specified.</li>
                                        <li><b>data</b> - The bytes that should be signed or validated. Required for x-www-form-urlencoded.</li>
                                        <li><b>filerecievefile</b> - File upload used with multipart/form-data.</li>
                                        <li><b>pdfPassword</b> - Password for changing PDF. Optionally and only used by PDFSigner.</li>
                                        <li><b>encoding</b> - Encoding of the data field. Optional. By specifying "base64" SignServer Base64-decodes
                                        the data property before passing it to the worker.</li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>Response code:</td>
                                <td>
                                    <ul>
                                        <li><b>HTTP 200</b> (OK): The request was successfull</li>
                                        <li><b>HTTP 400</b> (Bad Request): The request could not be fulfilled. Some request data were missing or incorrect etc.</li>
                                        <li><b>HTTP 401</b> (Unauthorized): The worker requires user authentication</li>
                                        <li><b>HTTP 404</b> (Not Found): The requested workerName or workerId does not represent an existing worker</li>
                                        <li><b>HTTP 413</b> (Request Entity Too Large): The data field or uploaded file is too large</li> 
                                        <li><b>HTTP 500</b> (Internal Server Error): There was an internal error when processing the request. Typically indicating an configuration problem or unexpected error at the server side.</li>
                                        <li><b>HTTP 503</b> (Service Unavailable): The worker is not active, its crypto token is not activated or similar</li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>Response content-type:</td><td>Depending on the worker</td>
                            </tr>
                        </table>
                        <p>
                            <sup>*</sup> if the request content-type in a POST is specified as something else than "x-www-form-urlencoded" or
                            "multipart/form-data" the message body is not parsed but instead directly passed to the worker specified by workerName or workerId
                            in the URI's query string.
                        </p>

                        <subsubsection name="Samples">
                            <ul>
                                <li>
                                    HTTP GET:<br/>
                                    http://localhost:8080/signserver/process?workerName=DemoXMLSigner&amp;data=%3Croot%3Ehej2%3C/root%3E<br/>
                                    http://localhost:8080/signserver/process?workerName=DemoXMLSigner&amp;encoding=base64&amp;data=PGhlajI%2Bb2s8L2hlajI%2BCg%3D%3D<br/>
                                    <br/>
                                </li>
                                <li>
                                    HTTP POST with multipart/form-data or x-www-form-urlencoded:<br/>
                                    For example see /signserver/demo/xmlsign.jsp (multipart/form-data) and /signserver/demo/genericsign.jsp (x-www-form-urlencoded).<br/>
                                    <br/>
                                </li>
                                <li>
                                    HTTP POST with other content-type:<br/>
                                    See the TimeStampClient.<br/>
                                    <br/>
                                </li>
                            </ul>
                        </subsubsection>

                    </subsection>
                    <subsection name="SODProcessServlet">
                        <p>
                            Servlet recieving HTTP POST requests containing data group hashes
                            and creates a MRTDSODSignerRequest and passes it to the specified
                            MRTDSODSigner. The response from the servlet is the signed security
                            object in binary format.
                        </p>
                        <table>
                            <tr>
                                <td>URL:</td><td><b>/signserver/sod</b></td>
                            </tr>
                            <tr>
                                <td>Method:</td><td> <b>POST</b></td>
                            </tr>
                            <tr>
                                <td>Request parameters:</td>
                                <td>
                                    <ul>
                                        <li><b>workerName</b> - Name of the worker that should handle the request. Required unless workerId specified.</li>
                                        <li><b>workerId</b> - Id of the worker that should handle the request. Required unless workerName specified.</li>
                                        <li><b>dataGroup1 to dataGroup16</b> - The data group hashes that should be put in the SO(d). At least one required.</li>
                                        <li><b>encoding</b> - Encoding of the data group hash fields. Optional. By specifying "base64" SignServer Base64-decodes
                                        the data property before passing it to the MRTDSODSigner.</li>
                                        <li><b>ldsVersion</b> - Request a specific LDS version: "0107" for V1.7 or "0108" for V1.8. Optional. If not specified the version from the configuration is used. If version is V1.8 unicodeVersion also needs to be specified.</li>
                                        <li><b>unicodeVersion</b> - Unicode version to store in the SOd. Optional. Only supported if ldsVersion "0108" specified. Specify "040000" for Unicode version 4.0.0.</li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>Response code:</td><td>The same response codes as for the GenericProcessServlet are used.</td>
                            </tr>
                            <tr>
                                <td>Response content-type:</td><td><b>application/octet-stream</b></td>
                            </tr>
                        </table>


                        <subsubsection name="Samples">
                            <ul>
                                <li>
                                    See /signserver/demo/mrtdsodsign.jsp.<br/>
                                    <br/>
                                </li>
                            </ul>
                        </subsubsection>
                    </subsection>
		</section>

                <section name="Client Command Line Interface (CLI)" shortname="clientcli">
                    <p>
Requests can be sent to the workers using the Client CLI. After building
SignServer the script bin/client.sh can be run.
                    </p>
                    <source>
$ bin/client.sh
INFO  usage: client &lt;signdocument | validatedocument | timestamp | validatecertificate | signdatagroups&gt;
                    </source>

                    <subsection name="signdocument">
                        <p>
Request signing of a document using HTTP(s) or web services. 
                        </p>
                        <source>
usage: signdocument &lt;-workername WORKERNAME | -workerid WORKERID&gt;
                    [options]
Request a document to be signed by SignServer
 -data             Data to send to the worker.
 -host             Server name or IP address. Default: localhost
 -infile           File to read data to send to the worker from.
 -keyalias         Alias of the key in the keystore to use for
                   authentication.
 -keystore         Keystore with private key and certificate for client
                   certificate authentication.
 -keystorepwd      Password for reading the keystore.
 -outfile          File to write the result to. If not specified the
                   result is written to stdout.
 -password         Password for authentication.
 -pdfpassword      Password for changing the PDF (if required).
 -port             Server port. Default: 8080 (for HTTP), 8442 for HTTPS
                   and 8443 for HTTPS with client authentication.
 -protocol         Method of interacting with SignServer. HTTP or
                   WEBSERVICES. Default: HTTP.
 -servlet          Servlet to call. Default /signserver/process
 -truststore       Keystore with trusted certificates to use with HTTPS.
 -truststorepwd    Password for the keystore with trusted certificates.
 -username         Username for authentication.
 -workerid         ID of worker which should perform the operation.
 -workername       Name of worker which should perform the operation.

Sample usages:
a) signdocument -workername XMLSigner -data "&lt;root/&gt;"
b) signdocument -workername XMLSigner -infile /tmp/document.xml
c) signdocument -workerid 2 -data "&lt;root/&gt;" -truststore truststore.jks
-truststorepwd changeit
d) signdocument -workerid 2 -data "&lt;root/&gt;" -keystore superadmin.jks
-truststorepwd foo123
                        </source>
                    </subsection>

                    <subsection name="validatedocument">
                        <p>
Request a document to be validated.
                        </p>
                        <source>
usage: validatedocument &lt;-workername WORKERNAME | -workerid WORKERID&gt;
                        [options]
Request a document to be validated by SignServer
 -data             Data to send to the worker.
 -host             Server name or IP address. Default: localhost
 -infile           File to read data to send to the worker from.
 -keyalias         Alias of the key in the keystore to use for
                   authentication.
 -keystore         Keystore with private key and certificate for client
                   certificate authentication.
 -keystorepwd      Password for reading the keystore.
 -password         Password for authentication.
 -port             Server port. Default: 8080 (for HTTP), 8442 for HTTPS
                   and 8443 for HTTPS with client authentication.
 -truststore       Keystore with trusted certificates to use with HTTPS.
 -truststorepwd    Password for the keystore with trusted certificates.
 -username         Username for authentication.
 -workerid         ID of worker which should perform the operation.
 -workername       Name of worker which should perform the operation.

Sample usages:
a) validatedocument -workername XMLValidator -data "&lt;root&gt;&lt;Signature...
b) validatedocument -workername XMLValidator -infile /tmp/signed.xml
c) validatedocument -workerid 2 -infile /tmp/signed.xml -truststore
truststore.jks -truststorepwd changeit
d) validatedocument -workerid 2 -infile /tmp/signed.xml -keystore
superadmin.jks -truststorepwd foo123
                        </source>
                    </subsection>

                    <subsection name="timestamp">
                        <source>
$ bin/client.sh timestamp
usage: java -jar timeStampClient.jar &lt;options> &lt;url&gt;
 -instr &lt;string&gt;      String to be time stamped, if neither instr or
                      infile is given, the client works in test-mode generating it's own
                      message.
 -base64              Give this option if the stored request/reply should
                      be base64 encoded, default is not.
 -help                Print this message.
 -infile &lt;file&gt;       File containing message to time stamp.
 -inrep &lt;file&gt;        Input file containing an earlier stored base64
                      encoded response, to verify.You must specify the verify flag also.
 -inreq &lt;file&gt;        Input file containing an earlier stored request to
                      use instead of creating a new. You must specify the request flag also.
 -outrep &lt;file&gt;       Output file to store the recevied TSA reply, if not
                      given the reply is not stored.
 -outreq &lt;file&gt;       Output file to store the sent TSA request, if not
                      given the request is not stored.
 -signerfile &lt;file&gt;   Input file containing the PEM encoded certificate of
                      the TSA signer.Used to verify a stored response.
 -sleep &lt;num&gt;         Sleep a number of milliseconds after each request.
                      Default 1000 ms.
 -url &lt;url&gt;           Url of TSA, e.g.
                      http://127.0.0.1:8080/signserver/process?workerId=1.
 -verify              Give this option if verification of a stored reply
                      should be done, work together with inrep and cafile. If given, no request
                      to the TSA will happen.

Sample usages:
a) timestamp -url http://localhost:8080/signserver/tsa?workerName=TimeStampSigner

                        </source>
                    </subsection>

                    <subsection name="validatecertificate">
                        <p>
Request a certificate to be validated by the specified service.
                        </p>
                        <source>
usage: Usage: java -jar validate.jar &lt;options&gt;

 -cert &lt;cert-file&gt;              Path to certificate file (DER or PEM)
                                (Required).
 -certpurposes &lt;certpurposes&gt;   A ',' separated string containing
                                requested certificate purposes.
 -der                           Certificate is in DER format.
 -help                          Display this info
 -hosts &lt;hosts&gt;                 A ',' separated string containing the
                                hostnames of the validation service nodes. Ex
                                'host1.someorg.org,host2.someorg.org' (Required).
 -pem                           Certificate is in PEM format (Default).
 -port &lt;port&gt;                   Remote port of service (Default is 8080 or
                                8442 for SSL).
 -service &lt;service-name&gt;        The name or id of the validation service
                                to process request. (Required)
 -silent                        Don't produce any output, only return
                                value.
 -truststore &lt;jks-file&gt;         Path to JKS truststore containing trusted
                                CA for SSL Server certificates.
 -truststorepwd &lt;password&gt;      Password to unlock the truststore.

The following values is returned by the program that can be used when scripting.
  -2   : Error happened during execution
  -1   : Bad arguments
   0   : Certificate is valid
   1   : Certificate is revoked
   2   : Certificate is not yet valid
   3   : Certificate have expired
   4   : Certificate doesn't verify
   5   : CA Certificate have been revoked
   6   : CA Certificate is not yet valid
   7   : CA Certificate have expired.
   8   : Certificate have no valid certificate purpose.

Sample usages:
a) validatecertificate -service CertValidationWorker -hosts localhost -cert
    certificate.pem
b) validatecertificate -service 5806 -hosts localhost -cert certificate.pem
    -truststore p12/truststore.jks -truststorepwd changeit
                        </source>
                    </subsection>

                    <subsection name="signdatagroups">
                        <p>
Sign the specified data groups and produce an SOd (MRTD).
                        </p>
                        <source>
$ bin/client.sh signdatagroups
usage: signdatagroups &lt;options&gt;
 -data             Data to send to the worker.
 -encoding         Encoding of the data option. None or base64. Default:
                   none.
 -host             Server name or IP address. Default: localhost
 -keyalias         Alias of the key in the keystore to use for
                   authentication.
 -keystore         Keystore with private key and certificate for client
                   certificate authentication.
 -keystorepwd      Password for reading the keystore.
 -password         Password for authentication.
 -port             Server port. Default: 8080 (for HTTP), 8442 for HTTPS
                   and 8443 for HTTPS with client authentication.
 -repeat           Run the operation this number of times. Default: 1
 -servlet          Servlet to call. Default /signserver/sod
 -truststore       Keystore with trusted certificates to use with HTTPS.
 -truststorepwd    Password for the keystore with trusted certificates.
 -username         Username for authentication.
 -workerid         ID of worker which should perform the operation.
 -workername       Name of worker which should perform the operation.

Sample usages:
a) signdatagroups -workername MRTDSODSigner -data "1=value1&amp;2=value2&amp;3=value3"
                        </source>
                    </subsection>

                </section>

                <section name="Administration Web Service" shortname="adminws">
                    <p>
The SignServer AdminWS can be used for remote administration of SignServer
over client authenticated HTTPS. Access is granted based on a list of
certificate serial number and issuer distinguished name pairs. Currently there
is only one access level and all administrators granted access will be able to
perform all operations.
                    </p>
                    <p>
The WSDL file is located at the URL http://&lt;hostname&gt;:8080/signserver/AdminWSService/AdminWS?wsdl
                    </p>
                    <p>
Authorizing administrators can be done using the Admin CLI command "wsadmins".
                    </p>
                    <source>
Usage: signserver wsadmins -add -certserialno &lt;certificate serial number&gt; -issuerdn &lt;issuer DN&gt;
Usage: signserver wsadmins -remove -certserialno &lt;certificate serial number&gt; -issuerdn &lt;issuer DN&gt;
Usage: signserver wsadmins -list
Example 1: signserver wsadmins -add -certserialno 123abcdef -issuerdn "C=SE, CN=Neo Morpheus"
Example 2: signserver wsadmins -remove -certserialno 123abcdef -issuerdn "C=SE, CN=Neo Morpheus"
Example 3: signserver wsadmins -list
                    </source>
                    <p>
Notice that the certificate serial number should be entered with lower case characters. 
Also notice that the issuer DN currently should be entered in the reversed order 
and with spaces after each component. In the example above the issuer DN from the 
certificate actually is "CN=Neo Morpheus, C=SE". 
                    </p>
                    <p>
To troubleshoot an "Administrator not authorized to resource" see the logs for how 
SignServer interprets the serialnumber and subject DN. Example:
                    </p>
                    <pre>
19:00:33,946 INFO  [AdminWS] ADMIN OPERATION; subjectDN=C=SE, O=Markus Organization, OU=Internal Testing 1, CN=External RA Admin 1; serialNumber=4a3442e98e3ce428; issuerDN=C=SE, O=Markus Organization, OU=Internal Testing 1, CN=MarkusAdminCA1; authorized=false; operation=getWorkers; arguments=
                    </pre>
                </section>
        </chapter>

        <chapter name="Common configuration" shortname="commonconf">

		<p>
		Configuring workers are done by setting properties in the worker configuration.
		There is one set of configuration options that are handled by the framework, and that applies to all workers, then there are worker specific properties handled by the worker implementation.
		</p>
		<p>Properties are usually defined in the module configuration file used to install a module, or configured manually using one of the <i>bin/signserver setproperty</i> variant.</p>
		
            <section name="Setting Authorization Type">
                <subsection name="SignServer">
                    <p>
By default (if the property is not set) is client-certificate authentication required for a signature request to be processed. This can be changed with the AUTHTYPE property.
                    </p>
                    <subsubsection name="No authentication">
                        <p>
<b>AUTHTYPE</b> =  NOAUTH
                        </p>
                        <p>
Sets the server to not require any authentication.
                        </p>
                    </subsubsection>
                    <subsubsection name="Client certificate authentication">
                        <p>
<b>AUTHTYPE</b> =  CLIENTCERT
                        </p>
                        <p>
 (default) requires a certificate of all the clients. The certificates must be 
 in the application server's truststore. Authorized clients is configured
 manually using the CLI interface.
                        </p>
                    </subsubsection>
                    <subsubsection name="Username/password-based authentication">
                        <p>
<b>AUTHTYPE</b> = org.signserver.server.UsernamePasswordAuthorizer
                        </p>
                        <p>
<b>USER.[NAME]</b> = [PASSWORD]<br/>
<b>USER.[NAME]</b> = [HASHED_PASSWORD]:[HASH_ALGORITHM]<br/>
<b>USER.[NAME]</b> = [HASHED_PASSWORD]:[HASH_ALGORITHM]:[SALT]<br/>
                        </p>
                        <p>
This authorizer requires a valid username and password. User accounts are
configured by setting properties of the form shown above, where
[NAME] is the username and [PASSWORD] is the clear-text password. In the second
form [HASHED_PASSWORD] should be replaced with the output of the digest algorithm 
specified in [HASH_ALGORITHM]. The third form uses a hash value that is appended 
to the password before hashing it.
                        </p>
                        <p>
If a valid username and
password is not supplied the worker throws an AuthorizationRequiredException
which in case of the HTTP interfaces causes a HTTP Basic Authentication (RFC 2617).
                        </p>
                    </subsubsection>
                    <subsubsection name="Username-based authentication">
                        <p>
<b>AUTHTYPE</b> = org.signserver.server.UsernameAuthorizer
                        </p>
                        <p>
Form 1: ACCEPT_ALL_USERNAMES = false (default) and usernames are specified:<br/>
<b>ACCEPT_ALL_USERNAMES</b> = false<br/>
<b>ACCEPT_USERNAMES</b> = user1;user2;user3
                        </p>
                        <p>
Form 2, ACCEPT_ALL_USERNAMES = true and no usernames are specified:<br/>
<b>ACCEPT_ALL_USERNAMES</b> = true
                        </p>
                        <p>
An Authorizer that can be used for instance if SignServer sits behind an Apache
front-end which uses HTTP basic authentication. With this Authorizer the username
is logged but the password is not checked as it is assumed to be checked by the
front-end.
                        </p>
                        <p>
The Authorizer can be configured to either accept all usernames or only accept
those usernames listed in one of its properties.
                        </p>
                    </subsubsection>
                    <subsubsection name="Remote address authentication">
                        <p>
<b>AUTHTYPE</b> = org.signserver.server.RemoteAddressAuthorizer
                        </p>
                        <p>
<b>ALLOW_FROM</b> = Comma separated list of IP addresses to allow requests from.
By default all other addresses are denied access.
                        </p>
                        <p>
If a worker is invoked directly using an EJB call and no REMOTE_IP is specified
in the RequestContext the IP-address is set to the String "null". In that case,
to allow requests using EJB calls, null can be added to the list of allowed
addresses.
                        </p>
                        <p>
<b>Note:</b> When adding "null" to ALLOW_FROM not only locally running clients
like the ClientCLI and AdminGUI is allowed access but also from workers that
invoke the other worker directly using an EJB call. This is for instance the
case for the XMLValidator which delegates the validation of the certificate to
a CertValidator. If the CertValidator had a RemoteAddressAuthorizer allowing
access from "null" then the XMLValidator would be able to use it. To restrict
users from using the CertValidator (indirectly through the XMLValidator) an
Autorizer could be configured for the XMLValidator.
                        </p>
                    </subsubsection>
                    <subsubsection name="Custom">
                        <p>
This authorization functionality doesn't work for all use cases. Then it's possible to create a customized authorizer and specify it's class path as value in the AUTHTYPE property. The Processable will then automatically instantiate and use it. How to develop such a plug-in is explained in the developers section.
                        </p>
                    </subsubsection>
                </subsection>
            </section>

            <section name="Archiving Responses">
                <p>
The archiving feature can be used to save all generated responses.    
                </p>
                <p>
For the OldDatabaseArchiver the Admin CLI can be used to query the archive. See 
the CLI section for more information.
                </p>
                <p>
When a requst has been process each Archiver is called one at the time to archive 
any results.
                </p>
                <p>
<b>ARCHIVERS</b>: Used instead of the old ARCHIVE property to enable archinving 
by listing the class names of all the Archivers that should be used. Multiple 
Archivers can be specified separated by a "," (comma character). Exempel: 
                </p>
<source>
ARCHIVERS=org.signserver.server.archive.olddbarchiver.OldDatabaseArchiver,org.signserver.server.archive.otherarchiver.OtherArchiver123
</source>
                <p>
<b>ARCHIVE</b>: Previously the archiving was enabled by setting the property to 
"TRUE". This is the same as to set 
                </p>
<source>
ARCHIVERS=org.signserver.server.archive.olddbarchiver.OldDatabaseArchiver
</source>
                <p>
Default: FALSE.
                </p>
            </section>

            <section name="Checking validity of signer certificates">
                <p>
By default the SignServer checks if the signer certificate of a signer is valid before letting the signer process a request. If the signers certificate is not valid an error message is returned.
There are two properties that can be set to disable this check:
                </p>
                <p>
<b>CHECKCERTVALIDITY</b>: default value is true, meaning that the validity period of the certificate will be verified before processing. Set to false to ignore if the certificate is expired or not yet valid.
                </p>
                <p>
<b>CHECKCERTPRIVATEKEYVALIDITY</b>: default value is true, meaning that the validity period in the PrivateKeyUsagePeriod of the certificate will be verified before processing. This is only done if this extension exists (it is optional in a certificate). Set to false to ignore the PrivateKeyUsagePeriod.
                </p>
                <p>
<b>MINREMAININGCERTVALIDITY</b>: default value is 0. This property defines a minimum remaining validity time required of the signing certificate. If the signing certificate expires within the number of days specified an error occurs. Set to 0 (default) to disable this check.
				</p>
            </section>

			<section name="Limiting the number of signatures">
                <p>
<b>KEYUSAGELIMIT</b> = Sets how many signatures that are allowed to be created
with the same key by this worker (default is -1 = no limit). After the limit has
been reached the worker is considered offline.

Note that the counter is per key and not per worker so if multiple workers share
the same key they will all increment the counter. This also means that the worker
is active again after it has gotten a new certificate/key.
                </p>			
			</section>                    
		</chapter>
		
        <chapter name="Plugins" shortname="plugins">
            <!--<p> TODO:
from: manual31.odt:ch7, src
There could also be a listing of all modules and for each module:
a description of its purpose and
description of each of its properties.
            </p>-->
            <section name="Configuring a plug-in">
                <p>
A worker component is configured by entering its class path (and optionally its crypto token class path) in a memory bank called the global configuration and then issuing the reload command. There exists sample configurations for most of the plug-ins in the 'doc/sample-configs' directory.
                </p>
            </section>

            <section name="SignServer Signers">
                <p>
There exists multiple signers. One is the time stamp signer generating RFC 3161 compliant timestamps using the Bouncycastle library.
An MRTD signer creating "Machine Reader Travel Document" signatures using the RSA algorithm from pre-padded data and
another is the MRTD SOD Signer which creates the complete Security Object (SOd) by signing the datagroups for the passport.
There are also signers for automatically signing of specific document-types 
such as PDF, XML, ODF and OOXML and there is a general purpose signer that
can sign any document-type and produces the output in Cryptographic Message Syntax (CMS).
                </p>

                <subsection name="Time-stamp Signer">
                    <p>
The time-stamp signer has the class name: org.signserver.server.signers.TimeStampSigner
                    </p>

                    <subsubsection name="Overview">
                        <p>
The time stamp server generates time stamp tokens and have the support for the following options:
                        </p>
                        <ul>
                            <li>Set of accepted policies</li>
                            <li>Set of accepted algorithms</li>
                            <li>Set of accepted extensions</li>
                            <li>Accuracy microseconds</li>
                            <li>Accuracy milliseconds</li>
                            <li>Accuracy seconds</li>
                            <li>Included certificate chain (currently doesn't include CRLs)</li>
                            <li>Ordering</li>
                            <li>TSA name</li>
                        </ul>
                        <p>
The time stamp signer currently don't support:
                        </p>
                        <ul>
                            <li>CRL inclusion</li>
                            <li>Signed attributes</li>
                            <li>Unsigned attributes </li>
                        </ul>
                        <p>
Timestamps requests are served through a http service at the URL:
                        </p>
                        <pre>
'http://&lt;host name&gt;/signserver/process?workerId=&lt;worker Id&gt;'
                        </pre>
                        <p>
If no 'worker Id' parameter is specified then will the id of 1 be used as default.
                        </p>
                        <p>
The time-stamp signer requires a time-stamp certificate with the extended key usage 'time-stamp' only. The extended key usage extension must be critical.
                        </p>
                    </subsubsection>

                    <subsubsection name="Available Properties">
                        <p>
The following properties can be configured with the signer:
                        </p>
                        <p>
<b>TIMESOURCE</b> = property containing the fully qualified name of the class implementing  the ITimeSource that should be used (OPTIONAL). Below are the built-in TimeSourceS available:
                        </p>
                        <table>
<!-- LocalComputerTimeSource -->
                            <tr>
                                <td>
<b>org.signserver.server.LocalComputerTimeSource</b>
                                </td>
                            </tr>
                            <tr>
                                <td>
This is the default TimeSource and uses the time from the local computer and
always returns the time.
                                </td>
                            </tr>

<!-- StatusReadingLocalComputerTimeSource -->
                            <tr>
                                <td>
<b>org.signserver.server.StatusReadingLocalComputerTimeSource</b>
                                </td>
                            </tr>
                            <tr>
                                <td>
This TimeSource returns the time from the local computer but only if the
status property <i>INSYNC</i> is returned as <i>true</i> from the
Status Repository.
                                </td>
                            </tr>
                        </table>
                        
                        <p>
<b>ACCEPTEDALGORITHMS</b> = A ';' separated string containing accepted algorithms, can be null if it shouldn't be used. (OPTIONAL, Strongly recommended)
Supported Algorithms are: GOST3411, MD5, SHA1, SHA224, SHA256, SHA384, SHA512, RIPEMD128, RIPEMD160, RIPEMD256
                        </p>
                        <p>
<b>ACCEPTEDPOLICIES</b> =  A ';' separated string containing accepted policies, can be null if it shouldn't be used. (OPTIONAL, Recommended)
                        </p>
                        <p>
<b>ACCEPTEDEXTENSIONS</b> = A ';' separated string containing accepted extensions, can be null if it shouldn't be used. (OPTIONAL)
                        </p>
                        <p>
<b>DEFAULTTSAPOLICYOID</b> = The default policy ID of the time stamp authority (REQUIRED, if no policy OID is specified in the request then will this value be used.)
                        </p>
                        <p>
<b>ACCURACYMICROS</b> = Accuracy in micro seconds, Only decimal number format, only one of the accuracy properties should be set (OPTIONAL)
                        </p>
                        <p>
<b>ACCURACYMILLIS</b> = Accuracy in milliseconds, Only decimal number format, only one of the accuracy properties should be set (OPTIONAL)
                        </p>
                        <p>
<b>ACCURACYSECONDS</b> = Accuracy in seconds. Only decimal number format, only one of the accuracy properties should be set (OPTIONAL)
                        </p>
                        <p>
<b>ORDERING</b> = The ordering (OPTIONAL), default false. Only false is supported.
                        </p>
                        <p>
<b>TSA</b> = General name of the Time Stamp Authority. (OPTIONAL)
                        </p>
                    </subsubsection>
                </subsection>

                <subsection name="MRTD Signer">
                    <p>
The MRTD signer has the class name: org.signserver.server.signers.MRTDSigner
                    </p>
                    <subsubsection name="Overview">
                        <p>
The MRTD Signer performs a RSA signing operation on incoming data. The data should already be padded. This signer i used to sign 'Machine Readable Travel Documents' i.e. electronic passports.
                        </p>
                    </subsubsection>
                    <subsubsection name="Available Properties">
                        <p>
No configuration properties exists.
                        </p>
                    </subsubsection>
                </subsection>

                <subsection name="PDF Signer">
                    <p>
The PDF signer has the class name: org.signserver.module.PDFSigner
                    </p>

                    <subsubsection name="Overview">
                        <p>
The main purpose of the PDF signer is to add digital signatures to PDF documents. 
                        </p>
                        
                        <p>
The signer supports the addition of visible or invisible signatures. Both visible and invisible signatures serve the same purpose of signing document, and technically are equivalent in that sense. The difference is that when visible signature  is applied to a document, signature image (in shape of rectangle) is placed at the specified place in the document, clicking on which will allow seeing properties of the signature (Adobe Acrobat Reader). On the other hand when invisible signature is applied, signature properties are accessed through menu items. For visible signatures properties such as : custom signature image, signature rectangle, page at which signature rectangle to be drawn and others can be specified (see Available Properties below)
                        </p>
                        <p>
PDF Signer can also apply timestamp to a signature. If the signature is timestamped, it can be viewable through signature properties in Adobe Acrobat Reader. Timestamping is used to prove that  document was signed before the time specified by timestamp token. If the signature is not timestamped then the signature time specified in the signature properties is not considered to be trusted. It is strongly advised to apply timestamp to a signature, and the TSA module can be used for this purpose.
                        </p>
                        <p>
Also CRL or OCSP Response of the signer's certificate can be embedded inside the signature package. Embedding CRL or OCSP response with the package will help validate signature even after the signer's certificate is expired. (Though it will not totally guarantee the long term signature preservation. Topic of long term signature preservation for archival purposes is a large one and is discussed to be implemented in future versions of SignServer).
                        </p>
                        <p>
The PDF Signer can also be configured to enforce that certain PDF permissions are not available in the signed document and/or that certain permissions should be removed.
                        </p>
                    </subsubsection>
                    
                    <subsubsection name="PDF passwords">
                        <p>
PDF documents can optionally be protected by a password.
                        </p>
                        <p>
There are two different types of passwords:
                            <ul>
                                <li>
                                    User password:<br/>
                                    Also sometimes referred to as "open password" or "document password". It can be used for reading an encrypted document.
                                </li>
                                <li>
                                    Owner password:<br/>
                                    Also sometimes referred to as "permission password" or "security restriction password". It can be used for reading an encrypted document and making changes to a document that has permissions.
                                </li>
                            </ul>
If a document is protected by an owner password it has to be supplied with the request for SignServer to sign the document. If the document is protected by a user password, either the user password or the owner password has to be supplied with the request for SignServer to sign the document.
                        </p>
                    </subsubsection>
                    
                    <subsubsection name="PDFSigner Requests">
                        <p>
PDF signing requests can be served using either web services or the web server interface (HTTP). See <a href="integration.html">Integration</a> for general information about the different interfaces.    
                        </p>
                        
                        <p>
For the web server interface the GenericProcessServlet can be used. The PDFSigner supports the extra request field "pdfPassword" letting the client supply a PDF password to be used for opening the PDF for signing (not required unless the PDF is already password protected).
                        </p>
                        <p>
For the web services interface the request should contain an encoded GenericProcessesRequest and the response will be an GenericProcessResponse. It is possible to supply a PDF password by including it in the requestMetaData with the key "pdfPassword".
                        </p>
                    </subsubsection>

                    <subsubsection name="Worker Properties">
                        <p>
The following properties can be configured with the signer:
                        </p>
                        
                        <table>
                            <tr>
                                <td><b>REASON</b></td>
                                <td>
                                    <p>
The reason included in the PDF signature and displayed by the PDF reader. 
                                    </p>
                                    <p>
Default: "Signed by SignServer".
                                    </p>
                                </td>
                            </tr>
                                                                           
                            <tr>
                                <td><b>LOCATION</b></td>
                                <td>
                                    <p>
The location included in the PDF signature and displayed by the PDF reader. 
                                    </p>
                                    <p>
Default: "SignServer".
                                    </p>
                                </td>
                            </tr>
                            
                            <tr>
                                <td><b>ADD_VISIBLE_SIGNATURE</b></td>
                                <td>
                                    <p>
Setting that control whether signature to be added should be visible or invisible.
                                    </p>
                                    <p>
Possible values: True or False.
                                    </p>
                                    <p>
Default: "False"                                        
                                    </p>
                                </td>
                            </tr>
                            
                            <tr>
                                <td><b>VISIBLE_SIGNATURE_PAGE</b></td>
                                <td>
                                    <p>
Specifies the page on which the visible signature will be drawn. This property is ignored if ADD_VISIBLE_SIGNATURE is set to False.
                                    </p>
                                    <p>
Possible values:<br/>
"First" : signature drawn on first page of the document,<br/>
"Last"  : signature drawn on last page of the document,<br/>
page_number : signature is drawn on a page specified by numeric argument. If specified page number exceeds page count of the document ,signature is drawn on last page. If page_number specified is not numeric (or negative number) the signature will be drawn on first page
                                    </p>
                                    <p>
Default: "First".
                                    </p>
                                </td>
                            </tr>
                            
                            <tr>                        
                                <td><b>VISIBLE_SIGNATURE_RECTANGLE</b></td>
                                <td>
                                    <p>
Specifies the rectangle signature is going to be drawn in. 
                                    </p>
                                    <p>
This property is ignored if ADD_VISIBLE_SIGNATURE is set to False. Format is : (llx,lly,urx,ury).<br/>
Here :<br/>
llx =left lower x coordinate,<br/>
lly=left lower y coordinate,<br/>
urx =upper right x coordinate,<br/>
ury = upper right y coordinate<br/>
                                    </p>
                                    <p>
Default: "400,700,500,800".
                                    </p>
                                </td>
	                        </tr>
                        
                            <tr>
                                <td><b>VISIBLE_SIGNATURE_CUSTOM_IMAGE_BASE64 &amp; VISIBLE_SIGNATURE_CUSTOM_IMAGE_PATH</b></td>
                                <td>
                                    <p>
	If we want the visible signature to contain custom image, specify image as base64 encoded byte array. Alternatively custom image can be specified by giving a path to image on file system.
                                    </p>
                                    <p>
Note: if specifying a path to an image "\" should be escaped (thus C:\photo.jpg => "C:\\photo.jpg")
                                    </p>
                                    <p>
Note: if specifying image as base64 encoded byte array "=" should be escaped (this "BBCXMI==" => "BBCXMI\=\=")
                                    </p>
                                    <p>
If both of these properties are set then VISIBLE_SIGNATURE_CUSTOM_IMAGE_BASE64 will take priority.
                                    </p>
                                    <p>
If we do not want this feature then do not set these properties.
                                    </p>
                                    <p>
Default: not set (no custom image).
                                    </p>
                                    <p>
These properties are ignored if ADD_VISIBLE_SIGNATURE is set to False.
                                    </p>
                                    <p>
NOTE: in clustered environment it is more manageable and advised to specify image as base64 string, since image data will be stored in central database. Otherwise each node should contain copy of the image, and each image managed separately (ex: on image updates, or insertion of new image for different worker)
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td><b>VISIBLE_SIGNATURE_CUSTOM_IMAGE_SCALE_TO_RECTANGLE</b></td>
                                <td>
                                    <p>
	If we want our custom image to be resized to specified rectangle (set by VISIBLE_SIGNATURE_RECTANGLE) then set to True. If set to True image might look different that original (as an effect of resizing). If set to False the rectangle drawn will be resized to specified image's sizes.
                                    </p>
                                    <p>
If set to False llx and lly coordinates specified by VISIBLE_SIGNATURE_RECTANGLE property will be used for drawing rectangle (urx and ury will be calculated from specified image's size).
                                    </p>
                                    <p>
This property is ignored if ADD_VISIBLE_SIGNATURE is set to False or if custom image to use is not specified.
                                    </p>
                                    <p>
Possible values: True, False.
                                    </p>
                                    <p>
Default: "True".
                                    </p>
                                </td>
                            </tr>

                            <tr>
                                <td><b>CERTIFICATION_LEVEL</b></td>
                                <td>
                                    <p>
Set this property to have the document certified with a certifying signature.
                                    </p>
                                    <p>
Possible values:<br/>
NOT_CERTIFIED: The document is not certified.<br/>
FORM_FILLING: The document is certified but the form can be filled in without invalidating the signature.<br/>
FORM_FILLING_AND_ANNOTATIONS: The document is certified but the form can be filled in and annotations added without invalidating the signature.<br/>
NO_CHANGES_ALLOWED: The document is certified and no changes can be made.<br/>
                                    </p>
                                    <p>
Default: "NOT_CERTIFIED".
                                    </p>
                                </td>
                            </tr>
                            
                            <tr>
                                <td><b>TSA_URL</b></td>
                                <td>
                                    <p>
If we want to timestamp document signature, specify timestamp authority URL.
                                    </p>
                                    <p>
If we do not want to timestamp document signature, do not set property.
                                    </p>
                                    <p>
Note: if path contains characters "\" or "=" , these characters should be escaped (thus "\" = "\\", "=" =>"\=")
                                    </p>
                                    <p>
Default: not set (no timestamping).
                                    </p>
                                </td>
                            </tr>

                            <tr>
	                                <td><b>TSA_USERNAME &amp; TSA_PASSWORD</b></td>
                                    <td>
                                        <p>
If the TSA requires authentication for timestamping, specify username and password. If the TSA does not require authentication, do not set these properties. These properties are ignored if TSA_URL is not set (no timestamping).
                                        </p>
                                        <p>
Default: not set (tsa does not require authentication).
                                        </p>
                                    </td>
                            </tr>
                        
                            <tr>
	                                <td><b>EMBED_CRL</b></td>
                                    <td>
If we want to embed the CRL for signer certificate inside the signature package set to True, otherwise set to False.
                                        <p>
Default: "False".
                                        </p>
                                    </td>
                            </tr>
                        
                            <tr>
	                                <td><b>EMBED_OCSP_RESPONSE</b></td>
                                    <td>
                                        <p>
If we want to embed the OCSP response for the signer certificate inside the signature package set to True, otherwise set to False.
                                        </p>
                                        <p>
Note: issuer certificate (of signing certificate) should be in certificate chain.
                                        </p>
                                        <p>
Default: "False".
                                        </p>
                                    </td>
                            </tr>
                       
                            <tr>
                                    <td><b>ARCHIVETODISK</b></td>
                                    <td>
                                        <p>
If we want the produced signed document to be stored in the local file system set this property to true and add the ARCHIVETODISK_PATH_BASE property explained below.
                                        </p>
                                        <p>
Default: "False".
                                        </p>
                                    </td>
                            </tr>
                        
                            <tr>
                                    <td><b>ARCHIVETODISK_PATH_BASE</b></td>
                                    <td>
                                        <p>
The file path to the folder to store the signed documents in.
                                        </p>
                                        <p>
Required if ARCHIVETODISK is True.
                                        </p>
                                    </td>
                            </tr>
                        
                            <tr>
                                    <td><b>ARCHIVETODISK_PATH_PATTERN</b></td>
                                    <td>
                                        <p>
Pattern used for creating sub-folders under the ARCHIVETODISK_PATH_BASE folder. 
                                        </p>
                                        <p>
Current date can be put in by adding ${DATE:yyyy} where yyyy can be replaced be the same syntax as defined in the class java.text.SimpleDateFormat. Other fields are:
                                        <ul>
                                            <li>${WORKERID}</li>
                                            <li>${WORKERNAME}</li>
                                            <li>${REMOTEIP}</li>
                                            <li>${REQUESTID}</li>
                                            <li>${TRANSACTIONID}</li>
                                            <li>${USERNAME}</li>
                                        </ul>
                                        </p>
                                        <p>
Default: "${DATE:yyyy/MM/dd}".
                                        </p>
                                    </td>
                            </tr>
                        
                            <tr>
                                    <td><b>ARCHIVETODISK_FILENAME_PATTERN</b></td>
                                    <td>
                                        <p>
Pattern used for creating the filename. The same fields and syntax as for the ARCHIVETODISK_PATH_PATTERN property can be used.
                                        </p>
                                        <p>
Default: "${WORKERID}-${REQUESTID}-${DATE:HHmmssSSS}.pdf".
                                        </p>
                                    </td>
                            </tr>
                        
                            <tr>
                                    <td><b>REFUSE_DOUBLE_INDIRECT_OBJECTS</b></td>
                                    <td>
                                        <p>
True if PDF documents containing multiple indirect objects with the same name should be refused. Used to mitigate a collision signature  vulnerability described in <a href="http://pdfsig-collision.florz.de/">http://pdfsig-collision.florz.de/</a>.
                                        </p>
                                    </td>
                            </tr>
                            
                            <tr>
                                    <td><b>REJECT_PERMISSIONS</b></td>
                                    <td>
                                        <p>
Reject signing of the document if any of the permissions in the comma separated list would be in the document.
                                        </p>
                                        <p>
Available permissions:
                                            <ul>
                                                <li>ALLOW_PRINTING</li>
                                                <li>ALLOW_MODIFY_CONTENTS</li>
                                                <li>ALLOW_COPY</li>
                                                <li>ALLOW_MODIFY_ANNOTATIONS</li>
                                                <li>ALLOW_FILL_IN</li>
                                                <li>ALLOW_SCREENREADERS</li>
                                                <li>ALLOW_ASSEMBLY</li>
                                                <li>ALLOW_DEGRADED_PRINTING</li>
                                            </ul>
                                        </p>
                                        <p>
Default: unset/empty (no permissions are rejected)
                                        </p>
                                    </td>
                            </tr>
                            
                            <tr>
                                    <td><b>SET_PERMISSIONS</b></td>
                                    <td>
                                        <p>
Replace the current permissions (if any) with the permissions specified in this comma separated list of permissions.
                                        </p>
                                        <p>
Available permissions: The same permission names as for the property REJECT_PERMISSIONS.    
                                        </p>
                                        <p>
This property can not be specified if REMOVE_PERMISSIONS is used.    
                                        </p>
                                        <p>
Notice 1: This property and the REMOVE_PERMISSIONS property only sets the permissions setting in the document. All permissions might not be enforced by the PDF reader and some permissions even though specified by this property to be allowed might not be allowed when opening the final document (i.e. if that would invalidate the signature and/or certification).
                                        </p>
                                        <p>
Notice 2: If the document is not already protected by an owner password and the SET_OWNERPASSWORD is not specified a random password will be used as owner password.    
                                        </p>
                                        <p>
Default: unset (permissions are not set by this property)
                                        </p>
                                    </td>
                            </tr>
                            
                            <tr>
                                    <td><b>REMOVE_PERMISSIONS</b></td>
                                    <td>
                                        <p>
Remove all permissions specified in this comma separated list from the document.
                                        </p>
                                        <p>
Available permissions: The same permission names as for the property REJECT_PERMISSIONS.    
                                        </p>
                                        <p>
This property can not be specified if SET_PERMISSIONS is used.    
                                        </p>
                                        <p>
Notice: This property only removes the permissions listed even if some permissions (i.e. ALLOW_PRINTING) by the standard gives more permissions (i.e. also ALLOW_DEGRADED_PRINTING). To remove all permissions to print remove both ALLOW_PRINTING and ALLOW_DEGRADED_PRINTING. To still have ALLOW_DEGRADED_PRINTING it is possible to specify to only remove ALLOW_PRINTING.
                                        </p>
                                        <p>
See also Notice 1 and Notice 2 for REMOVE_PERMISSIONS which also applies to this setting.
                                        </p>
                                        <p>
Removing only ALLOW_DEGRADED_PRINTING has no effect as degraded printing is implicitly allowed if printing is allowed.    
                                        </p>
                                        <p>
Default: unset/empty (no permissions are removed)
                                        </p>
                                    </td>
                            </tr>
                            
                            <tr>
                                    <td><b>SET_OWNERPASSWORD</b></td>
                                    <td>
                                        <p>
Sets the specified password as owner password in the document.
                                        </p>
                                        <p>
The same permissions as before will be used (unless other properties will change them). The same encryption algorithm as the original document will be used. If the original document did not use any encryption then the default encryption algorithm will be used.    
                                        </p>
                                        <p>
Default: unset (if the permissions are changed, the existing owner password will be used or if no such password is used in the document a semi-random password will be created)
                                        </p>
                                    </td>
                            </tr>
                        </table>
                    </subsubsection>
                </subsection>

                <subsection name="ODF Signer">
                    <subsubsection name="Overview">
                        <p>
ODF Signer, which stands for Open Document Format Signer is a plug-in to SignServer that applies server side signature to documents in ODF format. It has been tested with OpenOffice.org 3.1.
                        </p>
                        <p>
	   ODF Signer supports only "invisible" signatures, that is unlike PDF signer there's no pictorial representation of the digital signature. When you open signed document in OpenOffice.org you can verify signature using toolbars, or the notifier in status bar (red mark), which notifies user that the document is digitally signed.
                        </p>
                    </subsubsection>
                    <subsubsection name="Available Properties">
                        <p>
	  Other than standard worker properties, ODF Signer does not have any other custom ODF signer specific properties.
                        </p>
                    </subsubsection>
                </subsection>

                <subsection name="XML Signer">
                    <subsubsection name="Overview">
                        <p>
The XML Signer creates enveloped XML signatures using XMLDSig.
                        </p>
                        <p>
The signed XML document can be validated using the XML Validator.
                        </p>
                    </subsubsection>
                    <subsubsection name="Available Properties">
                        <p>
This signer has no extra properties above the standard worker properties.
                        </p>
                    </subsubsection>
                </subsection>

                <subsection name="OOXML Signer">
                    <subsubsection name="Overview">
                        <p>
OOXML Signer, which stands for Office Open XML Signer is a plug-in to SignServer that applies server side signature to documents in OOXML format. It has been tested with MS Office 2007.
                        </p>
                        <p>
	   Currently OOXML Signer supports only "invisible" signatures , that is unlike PDF signer there's no pictorial representation of the digital signature. When you open signed document in MS Office you can verify signature using toolbars, or the notifier in status bar (red mark), which notifies user that the document is digitally signed.
                        </p>
                    </subsubsection>
                    <subsubsection name="Available Properties">
                        <p>
	  Other than standard worker properties, OOXML Signer does not have any other custom OOXML signer specific properties.
                        </p>
                        <p>
NOTE : In later versions of OOXML Signer it is planned to add support for visible signatures and custom signature image.
                        </p>
                    </subsubsection>
                </subsection>

                <subsection name="CMS Signer">
                    <p>
The CMS signer has the fully qualified class name: org.signserver.module.cmssigner.CMSSigner
                    </p>
                    <subsubsection name="Overview">
                        <p>
The CMS signer can sign arbitrary data and produces a CMS (RFC 3852) SignedData
structure in binary format.
                        </p>
                        <p>
Currently the signed content is always embedded as well as the signer certificate.
                        </p>
                    </subsubsection>
                </subsection>
            </section>

            <section name="SignServer Document Validators">
                <p>
Document Validators checks the signature and the certificate(s) in documents.
                </p>

                <subsection name="XML Validator">

                    <subsubsection name="Overview">
                        <p>
The XML validator validates the signature of XML documents. The certificate is checked by the configured certificate validation service.
                        </p>
                    </subsubsection>
                    <subsubsection name="Available Properties">
                        <p><b>VALIDATIONSERVICEWORKER</b> = Name or id of validation service worker for handling certificate validation</p>
                        <p><b>RETURNDOCUMENT</b> = True if the response should contain the validated document</p>
                        <p><b>STRIPSIGNATURE</b> = True if the signature should be removed from the document if it is returned</p>
                    </subsubsection>
                </subsection>
            </section>

            <section name="SignServer Dispatchers">
                <p>
Dispatchers are workers that forwards the request to other workers.
                </p>

                <subsection name="FirstActiveDispatcher">

                    <p>
Fully qualified class name: org.signserver.server.dispatchers.FirstActiveDispatcher
                    </p>
                        
                    <subsubsection name="Overview">
                        <p>
Dispatches the request to the first of the configured workers that has an active
cryptotoken. This dispatcher can be useful if you want to have one worker to call
that forwards the request to any of the configured workers that has a valid
certificate etc.
                        </p>
                    </subsubsection>
                    <subsubsection name="Available Properties">
                        <p><b>WORKERS</b> = Comma separated list of workerNameS to try to forward requests to.</p>
                    </subsubsection>
                </subsection>
            </section>

            <section name="SignServer Validation Service Framework">
                <p>
The validation service framework is used to validate certificates from one or more issuers. It can be used to  have one central point of performing revokation statuses to simplify the integration of external PKIs within an enterprise.
                </p>
                <p>
The validation service framework also provides a validation cache that can be used to increase performance for those cases a application does multiple lookups of the same certificate within a short period of time.
                </p>
                <p>
Out-of-the-Box there exists a DefaultValidationService that should satisfy most use cases but it's possible to develop a custom ValidationService if necessary. See the developer section for more details.
                </p>
                <p>
All Validation Services is configured by specifying the org.signserver.validationservice.server.ValidationServiceWorker in the global configuration, then is the actual ValidationService configured in the worker configuration setting the class path in the property TYPE (Not necessary for the DefaultValidationService).
                </p>
                <p>
The validation service framework is mostly used with X509v3 certificates but other kinds of certificates is supported as well by design.
                </p>
                <p>
Another concept in the Validation Service Framework is that the client also can ask the service to check the type of certificate that the certificate might be used for. A certificate type could be IDENTIFICATION or ELECTRONIC SIGNATURE.
                </p>
                <subsection name="DefaultValidationService">
                    <subsubsection name="Overview">
                        <p>
The default validation service have a set of Validators. A validator is responsible to checking the validity against one or more issuers using for example CRL check or OCSP/XKMS lookup or just by checking some database. Currently there are no ready to use validators, these remain to be developed in future versions of the SignServer.
                        </p>
                        <p>
The Default Validation Service supports validations to be cached for some or all issuers for a specified amount of time.
                        </p>
                        <p>
If not configured otherwise will the validation service use the DefaultX509CertTypeChecker that determines the certificate type from the key usage in the certificate.  Key Encipherment and Digital Signature indicates a IDENTIFICATION type and Non-reputation indicates ELECTRONIC SIGNATURE.
                        </p>
                        <p>
There exists a validation specific WebService that can be used for platform independent client calls.
The WebService must be enabled during the build and isn't by default. The WebService WSDL file is located at the URL http://&lt;hostname&gt;:8080/signserver/validationws/validationws?wsdl and it contains two calls one is 'isValid' that performs the validation check and the other is a getStatus call that checks the health of the node and its underlying systems. The last calls can be used by clients for monitoring or implementing redundancy.
                        </p>
                    </subsubsection>
                    <subsubsection name="Available Properties">
                        <p>
The following properties can be configured with the default validation service:
                        </p>
                        <p>
The validation service have three types of properties, general properties (that applies for the service and all configured validators), validator properties (that only applies for a specific validator) and issuer properties (that only applies for an issuer configured in a specific validator).
                        </p>
                        <p>
<i>General Properties:</i><br/>
                        </p>
                        <p>
<b>CACHEDISSUERS</b> = A ';' separated list of issuer names (usually issuer DNs)  (Optional, no validation is cached if unset.)
                        </p>
                        <p>
<b>CERTTYPECHECKER</b> = Certificate type checker that should be used to determine the type of certificate (Optional, default is org.signserver.validationservice.server.DefaultX509CertTypeChecker)
                        </p>
                        <p>
<b>TIMEINCACHE</b> = Time in seconds a certificates validation should be cached (Optional, default is 10 seconds)
                        </p>
                        <p>
<i>Validator properties:</i><br/>
Validator properties is specified with the prefix of 'validator&lt;validatorId&gt;.' or 'val&lt;validatorId&gt;.' were validator Id should be an integer between 1 and 255. For instance, to specify the type of a validator with an id of 1 then specify 'val1.classpath=some.classpath.SomeClass'. This validator will be initialized with all its validator specific properties (with 'val&lt;id&gt;.' prefix removed) as well as the general ones.
                        </p>
                        <p>
<b>CLASSPATH</b> = Class path to the validator that should be used. (Required for each configured validator)
                        </p>
                        <p>
<i>Issuer properties:</i>  Issuer properties are specified as 'val&lt;val id&gt;.issuer&lt;issuer id&gt;.&lt;property&gt;' were issuer id is a positive integer between 1 and 255. All generic and validator specific properties (with the given validator id) will also be propagated to the specific issuer configuration.
                        </p>
                        <p>
<b>CERTCHAIN</b> = The certificate path of the CA certificates used to verify the certificate. Should be a appended BASE64 string. (Required for each configured issuer).
                        </p>
                        <p>
Here is an example configuration of a validation service to clarify things even further
                        </p>
                        <pre>
# Set up the worker -> validation service wrapper
GLOB.WORKER1.CLASSPATH= org.signserver.validationservice .server.ValidationServiceWorker
#Uncomment and set class path to custom validation service, othervise is default #used.
#WORKER1.TYPE=

# Name of Service (Optional)
WORKER1.NAME=ValidationService1

# Define TestCA2 and TestCA3 as a cached for 15 seconds, TestCA1 is Not cached.
WORKER1.CACHEDISSUERS=CN=TestCA2;CN=TestCA3
WORKER1.TIMEINCACHE=15

# Define a validator in charge of issuer TestCA1 and TestCA2
WORKER1.VAL1.CLASSPATH=&lt;Class path to some validator&gt;
WORKER1.VAL1.ISSUER1.CERTCHAIN=EFWAASDFADFASDFKASDKFW1231.....
WORKER1.VAL1.ISSUER2.CERTCHAIN=EFWAASDFADFASDFKASDKFW1231.....

# Define a validator in charge of issuer TestCA3
WORKER1.VAL2.CLASSPATH=&lt;Class path to some validator&gt;
WORKER1.VAL2.ISSUER1.CERTCHAIN=EFWAASDFADFASDFKASDKFW1231.....
                        </pre>
                    </subsubsection>
                </subsection>

                <subsection name="The Validation CLI interface.">
                    <p>
There exists a Java CLI tool that can be used to check the validity of a certificate from scripts. It supports a clustered SignServer installation by using the "Use first host that response OK" policy.
                    </p>
                    <p>
When compiling, make sure that setting validationclient.enabled is set to "true" in the build properties. The client is lib/SignServer-Client-ValidationCLI.jar.
                    </p>
                    <p>
Use the client with 'java -jar lib/SignServer-Client-ValidationCLI.jar &lt;options&gt;'.
                    </p>
                    <pre>
Here is a list of available options:

-cert &lt;cert-file&gt; 			: Path to certificate file (DER or PEM) (Required).
-certpurposes &lt;certpurposes&gt;  	: A ',' separated string containing requested certificate purposes.
-der                           			: Certificate is in DER format.
-help                          			: Display this info
-hosts &lt;hosts&gt;                 		: A ',' separated string containing the hostnames of the validation service nodes. Ex 'host1.someorg.org,host2.someorg.org' (Required)
-pem                    	       		: Certificate is in PEM format (Default).
-port &lt;port&gt;                   		: Remote port of service (Default is 8080 or 8442 for SSL).
-service &lt;service-name&gt;        	: The name or id of the validation service to process request. (Required)
-silent                        			: Don't produce any output, only return value.
-truststore &lt;jks-file&gt;         		: Path to JKS truststore containing trusted CA for SSL Server certificates.(for HTTPS connections)
-truststorepwd &lt;password&gt;      	: Password to unlock the truststore.


The following return values is used:

-2   : Error happened during execution
-1   : Bad arguments
0   : Certificate is valid
1   : Certificate is revoked
2   : Certificate is not yet valid
3   : Certificate have expired
4   : Certificate doesn't verify
5   : CA Certificate have been revoked
6   : CA Certificate is not yet valid
7   : CA Certificate have expired.
8   : Certificate have no valid certificate purpose.
                   </pre>

                </subsection>

                <subsection name="SignServer Group Key Service Framework">
                    <subsubsection name="Overview">
                        <p>
The group key service framework is used to manage and distribute group keys to clients in an organisation. The keys can be generated on demand or pre-generated at times when the system is not utilized a lot. The group keys can be both symmetric and asymmetric but one service can only distribute one type of key. If several kinds of keys are required should multiple services be set up within the same server.
                        </p>
                        <p>
The group keys are stored encrypted in database. The encryption key can be configured to be switched automatically after a defined number of encryptions to avoid overexposure of the cryptographic data. It is also possible to switch the encryption key manually.
                        </p>
                        <p>
The Framework requires an ExtendedCryptoToken, the difference are that the extended token have additional support for key export and symmetric key operations.
                        </p>
                        <p>
The Group Key Service have CLI commands for administration of the service such as pre-generate keys, manual switch of encryption key and removal of group keys.
                        </p>
                        <p>
The communication to the group key service is mainly done through the main Web Service interface. But other ways of communicating with the server might come in the future.
                        </p>
                        <p>
Authorization to group keys is very important and therefore should a special plug-in be developed  that looks up which clients that should have access to a specific group key which fit into the organisation needs. See the authorization chapter of how to develop a customized authorization plug-in.
                        </p>
                        <p>
The basic configuration of a group key service is very similar to that of a validation service. Two entries is required in the global configuration. The first is the class path for the Worker to GroupKeyService wrapper, then a class path reference to the extended crypto token used with the service. If not the default group key service should be used it is possible to define a custom one by specifying its class path in the TYPE worker property.
                        </p>
                    </subsubsection>
                    <subsubsection name="Available Properties">
                        <p>
<b>USEPREGENERATION</b> = Setting defining of keys should be pre-generated or generated on the fly when needed. If the pool of pre-generated keys gets empty will new keys always be generated automatically. (Optional, default is true)
                        </p>
                        <p>
<b>ENCKEYALG</b> =  Encryption algorithm used to encrypt the group keys stored in database. (Optional, default is "AES")
                        </p>
                        <p>
<b>ENCKEYSPEC</b> = Specification of the encryption key. (Optional, default is "256")
                        </p>
                        <p>
<b>GROUPKEYALG</b> =  Defines the type of group keys that this service should generate (Optional, default is "AES")
                        </p>
                        <p>
<b>GROUPKEYSPEC</b> = Specification of the generated group keys. (Optional, default is "256")
                        </p>
                        <p>
<b>KEYSWITCHTHRESHOLD</b> = Setting defining the number of group keys that should be  encrypted by the same encryption key before it's switched. (Optional, default is 100000)
                        </p>
                    </subsubsection>
                </subsection>
            </section>

            <section name="Other workers">
                <subsection name="RenewalWorker">

                    <p>
Fully qualified class name: org.signserver.module.renewal.worker.RenewalWorker
                    </p>

                    <subsubsection name="Overview">
                        <p>
The RenewalWorker can be used to generate new keys and then contact EJBCA using
web services to get a new certificate. The worker accepts
GenericPropertiesRequestS and returns GenericPropertiesResponseS.
                        </p>
                    </subsubsection>
                    <subsubsection name="Worker Properties">
                        <p><b>EJBCAWSURL</b> = URL to the EJBCA. Example: https://ca-server:8443/ejbca</p>
                        <p><b>TRUSTSTOREPATH</b> = Path to the keystore containing the CA's SSL server certificate as a trusted entry.</p>
                        <p><b>TRUSTSTORETYPE</b> = Type of keystore. JKS is supported.</p>
                        <p><b>TRUSTSTOREPASSWORD</b> = Password protecting the truststore keystore.</p>
                    </subsubsection>
                    <subsubsection name="Properties of renewee">
                        <p><b>KEYALG</b> = Algorithm for the key generation. Examples: RSA, DSA or ECDSA</p>
                        <p><b>KEYSPEC</b> = Key length (for RSA or DSA) or curve name (for ECDSA). Examples: 2048, 4096, secp256r1</p>
                        <p><b>EXPLICITECC</b> = True if explicit domain parameters should be used instead of NamedCurves. Default: false</p>
                        <p><b>DEFAULTKEY</b> = Key alias for the current key.</p>
                        <p><b>NEXTCERTSIGNKEY</b> = Key alias for the next key.</p>
                    </subsubsection>
                    <subsubsection name="Request Properties">
                        <p><b>WORKER</b> = Name of the worker that should be renewed.</p>
                        <p><b>FORDEFAULTKEY</b> = If the current key should be used instead of the next key or a new key. (Optional, default: false)</p>
                    </subsubsection>
                    <subsubsection name="Response Properties">
                        <p><b>RESULT</b> = "OK" if the renewal succeded otherwise "FAILURE".</p>
                        <p><b>MESSAGE</b> = Error message if any.</p>
                    </subsubsection>
                    <subsubsection name="Renewal modes">
                        <table>
                            <tr>
                                <th colspan="2">Renewee</th>
                                <th>Request</th>
                                <th colspan="2">Result</th>
                            </tr>
                            <tr>
                                <td><b>DEFAULTKEY</b></td>
                                <td><b>NEXTCERTSIGNKEY</b></td>
                                <td><b>FORDEFAULTKEY</b></td>
                                <td><b>DEFAULTKEY</b></td>
                                <td><b>NEXTCERTSIGNKEY</b></td>
                            </tr>
                            <tr>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>New key and alias</td>
                                <td>Removed</td>
                            </tr>
                            <tr>
                                <td>present</td>
                                <td>-</td>
                                <td>-</td>
                                <td>New key and alias</td>
                                <td>Removed</td>
                            </tr>

                            <tr>
                                <td>-</td>
                                <td>present</td>
                                <td>-</td>
                                <td>Alias from nextcertsignkey</td>
                                <td>Removed</td>
                            </tr>
                            <tr>
                                <td>present</td>
                                <td>present</td>
                                <td>-</td>
                                <td>Alias from nextcertsignkey</td>
                                <td>Removed</td>
                            </tr>

                            <tr>
                                <td>present</td>
                                <td>-</td>
                                <td>TRUE</td>
                                <td>Same alias</td>
                                <td>Same alias</td>
                            </tr>
                            <tr>
                                <td>present</td>
                                <td>present</td>
                                <td>TRUE</td>
                                <td>Same alias</td>
                                <td>Same alias</td>
                            </tr>
                        </table>
                    </subsubsection>
                </subsection>
            </section>

            <section name="Available CryptoTokens">
                <p>
                    There exists four types of crypto tokens (Formerly known as sign tokens), two for storing the keys in software, one general for communicating with cryptographic hardware through the PKCS11 interface and one for SmartCards. See the developer section for information about developing support for other HSMs.
                </p>
                <p>
Which CryptoToken a worker is using is determined by the its SIGNERTOKEN.CLASSPATH
property which should contain the fully qualified class name of the CryptoToken
implementation. In addition to that property one must also make sure that the
other properties needed by the particular crypto token are available.
                </p>

                <subsection name="General properties">
                    <p>
<b>SIGNERTOKEN.CLASSPATH</b>: Fully qualified class name of the crypto token
implementation to use. See below for available crypto tokens.
                    </p>
                    <p>
<b>KEYALG</b>: Key algorithm to use when generating new keys (Only for
    cryptotokens supporting key generation).
                    </p>
                    <p>
<b>KEYSPEC</b>: Key specification to use when generating new keys (Only for
    cryptotokens supporting key generation).
                    </p>
                </subsection>

                <subsection name="P12CryptoToken">
                    <subsubsection name="Overview">
                        <p>
A CryptoToken using a PKCS#12 (.p12/.pfx) key-store in the local file-system. 
                        </p>
                        <p>
In a clustered environment the key store must placed at the same location at all nodes.
                        </p>
                        <p>
The P12CryptoToken, doesn't support the destroyKey() method
                        </p>
                    </subsubsection>

                    <subsubsection name="SIGNERTOKEN.CLASSPATH">
                        <p>
The fully qualified class name is: <b>org.signserver.server.cryptotokens.JKSCryptoToken</b>
                        </p>
                    </subsubsection>

                    <subsubsection name="Available Properties">
                        <p>
<b>KEYSTOREPATH</b>: The full path to the key-store file to load. (required)
                        </p>
                        <p>
<b>KEYSTOREPASSWORD</b>: The password that locks the key-store. Used for automatic activation.
                        </p>
                        <p>
<b>DEFAULTKEY</b>: The key to use. If not specified the first found key is used. (optional)
                        </p>
                    </subsubsection>
                </subsection>

                <subsection name="JKSCryptoToken">
                    <subsubsection name="Overview">
                        <p>
A CryptoToken using a Java Key Store (.jks) in the file-system.
                        </p>
                        <p>
In a clustered environment must the key store be at the same location at all nodes.
                        </p>
                        <p>
The JKSCryptoToken, doesn't support the destroyKey() method
                        </p>
                    </subsubsection>

                    <subsubsection name="SIGNERTOKEN.CLASSPATH">
                        <p>
The fully qualified class name is: <b>org.signserver.server.cryptotokens.P12CryptoToken</b>
                        </p>
                    </subsubsection>

                    <subsubsection name="Available Properties">
                        <p>
<b>KEYSTOREPATH</b>: The full path to the key-store to load. (required)
                        </p>
                        <p>
<b>KEYSTOREPASSWORD</b>: The password that locks the key-store. Used for automatic activation.
                        </p>
                        <p>
<b>DEFAULTKEY</b>: The key to use. If not specified the first found key is used. (optional)
                        </p>
                        <p>
<b>NEXTCERTSIGNKEY</b>: The next key to use. See PKCS11CryptoToken. (optional)
                        </p>
                    </subsubsection>
                </subsection>

                <subsection name="PrimeCardHSMCryptoToken">
                    <subsubsection name="Overview">
                        <p>
Using PrimeCardHSM it's possible to use a SmartCard to generate 2048-bit RSA signatures. The SmartCard can perform about one signature a second. PrimeCardHSM is proprietary software by PrimeKey Solutions AB.
                        </p>
                        <p>
PrimeCardHSM requires PCSCD software and SmartCard drivers. See separate documentation about installing PrimeCardHSM.
                        </p>
                        <p>
The PrimeCardHSMCryptoToken, doesn't support the destroyKey() method.
                        </p>
                    </subsubsection>

                    <subsubsection name="SIGNERTOKEN.CLASSPATH">
                        <p>
The fully qualified class name is: <b>org.signserver.server.cryptotokens.PrimeCardHSMCryptoToken</b>
                        </p>
                    </subsubsection>

                    <subsubsection name="Available Properties">
                        <p>
<b>DEFAULTKEY</b> =   Hash value of the signing key on the card. See PrimeCardHSM documentation for more information.(Required)
                        </p>
                                                <p>
<b>NEXTCERTSIGNKEY</b>: The next key to use. See PKCS11CryptoToken. (optional)
                        </p>
                        <p>
<b>AUTHCODE</b> = Authentication code for automatic activation (Optional).
                        </p>
                    </subsubsection>
                </subsection>

                <subsection name="PKCS11CryptoToken">
                    <subsubsection name="Overview">
                        <p>
Using PKCS11 it's possible to use a HSM that has a PKCS11 module, such as Utimaco, nCipher, SafeNet or AEP KeyPer. SignServer uses the same underlying implementation of
PKCS11 crypto tokens as EJBCA. To find out more about supported devices and get information how to configure them you can visit the HSM documentation at <a href="http://ejbca.org/adminguide.html#Hardware%20Security%20Modules%20%28HSM%29">EJBCA.org</a>. 
The only thing that differs are the token labels strings, which you should use from below for SignServer. A very useful tool from EJBCA is the <a href="http://ejbca.org/userguide.html#EJBCA%20client%20toolbox">ClientToolBox</a>. 
If you can generate anbd test PKCS11 keys using the clientToolBox, you can use them with SignServer.
                        </p>
                    </subsubsection>
                    <subsubsection name="SIGNERTOKEN.CLASSPATH">
                        <p>
The fully qualified class name is: <b>org.signserver.server.cryptotokens.PKCS11CryptoToken</b>
                        </p>
                    </subsubsection>
                    <subsubsection name="Available Properties">
                        <p>
<b>DEFAULTKEY</b> =   The key alias. (Required)
                        </p>
                        <p>
<b>NEXTCERTSIGNKEY</b> = The next key to use. This property can be used to hold
the name of the next key to use. Certificate signing requests (CSR) can be made
for this key can while to the current key (DEFAULTKEY) is still in production.
After uploading the new certificate the value of NEXTCERTSIGNKEY can be moved to
DEFAULTKEY. (optional)
                        </p>
                        <p>
<b>PIN</b> =   Authentication code for activation. (Required)
                        </p>
                        <p>
<b>SHAREDLIBRARY</b> =   Full path to the library containing the PKCS11 interface. (Required)
                        </p>
                        <p>
<b>SLOT</b> or <b>SLOTLISTINDEX</b> =   Slot number or the index of the slot to use. (Required and only one of them can be used.)
                        </p>
                        <p>
<b>ATTRIBUTESFILE</b> = Path to file with PKCS#11 attributes used for key generation.
                        </p>
                        <p>
Sample p11attributes.cfg working with SafeNet Luna:
                        </p>
                        <pre>
attributes(generate,*,*) = {
  CKA_TOKEN = true
}
attributes(generate,CKO_PUBLIC_KEY,*) = {
  CKA_ENCRYPT = true
  CKA_VERIFY = true
  CKA_WRAP = true
}
attributes(generate, CKO_PRIVATE_KEY,*) = {
  CKA_EXTRACTABLE = false
  CKA_DECRYPT = true
  CKA_SIGN = true
  CKA_UNWRAP = true
}
                        </pre>
                    </subsubsection>
                    <subsubsection name="Example usage">
                        <p>
Edit qs_pdfsigner_configuration.properties and choose the sign token setting for the PKCS11 sign token. Run the following command to set up a PDF signer using the PKCS11 properties configured:
bin/signserver setproperties qs_pdfsigner_configuration.properties
                        </p>
                        <p>
Generate a keypair for the signer:
bin/signserver generatekey 8 -alias defaultKey -keyalg RSA -keyspec 2048
                        </p>
                        <p>
Test the keypair:
bin/signserver testkey 8
                        </p>
                        <p>
You also need a certificate for the signer. Generate a certificate request with the command:
bin/signserver generatecertreq 8 "CN=PKCS11 Signer token" SHA1WithRSA /tmp/certreq.pem
                        </p>
                        <p>
Add a user in EJBCA with a certificate profile suitable for signing, and enrol for a "Server Certificate" using the public web pages.
                        </p>
                        <p>
Create the certificate chain file with the command:
cat /tmp/cert.pem /tmp/AdminCA1.pem > /tmp/certchain.pem
                        </p>
                        <p>
The signer certificate must be first, and the root CA certificate last.
                        </p>
                        <p>
Upload the signing certificate chain to the signer using the command:
bin/signserver uploadsignercertificatechain 8 GLOB /tmp/certchain.pem
                        </p>
                        <p>
After the certificate chain has been uploaded to the server, the configuration must be reloaded and the server must be restarted. It is not sufficient to only reload the configuration.
                        </p>
                    </subsubsection>
                </subsection>

                <subsection name="SoftCryptoToken">
                    <subsubsection name="Overview">
                        <p>
The SoftCryptoToken is a simple token managing it's own soft keys instead of using a PKCS12 file. It can be used for test and demonstration purposes. The keys are stored in the worker's properties and is generated when genCertificateRequest is called. One key is used for all purposes and a new key is generated for every certificate request.
                        </p>
                        <p>
The method destroyKey is not supported.
                        </p>
                        <p>
There is also a tool available for constructing the properties from a PKCS12 file
in CryptoTokenUtils.java. To run the tool outside the IDE first build SignServer
by running "ant". After that the tool can be executed with something similar
to:
                        </p>
                        <pre>
java -cp lib/signserver-ejb.jar:lib/ext/1.6/bcprov-jdk.jar:lib/SignServer-Common.jar:lib/ext/ejbca-util.jar org.signserver.server.cryptotokens.CryptoTokenUtils createsoft src/test/dss10/dss10_signer1.p12 "signer 1" foo123
                        </pre>
                    </subsubsection>
                    <subsubsection name="SIGNERTOKEN.CLASSPATH">
                        <p>
The fully qualified class name is: <b>org.signserver.server.cryptotokens.SoftCryptoToken</b>
                        </p>
                    </subsubsection>
                    <subsubsection name="Available Properties">
                        <p>
<b>KEYDATA</b> =   The serialized KeyPair generated by genCertificateRequest, usually is this setting configured by the SoftCryptoToken itself.
                        </p>
                        <p>
<b>KEYALG</b> = The algorithm used when generating new keys. (Optional, default is "RSA")
                        </p>
                        <p>
<b>KEYSPEC</b> =   The key specification used when generating new keys. (Optional, default is "2048")
                        </p>
                    </subsubsection>
                    <subsubsection name="Example usage">
                        <p>
First change the global property of WORKER&lt;ID&gt;.CRYPTOTOKEN.CLASSPATH of the worker you want to use the SoftCryptoToken with. After reload will an empty and inactive SoftCryptoToken be created.
                        </p>
                        <p>
Then generate a certificate request with the command, in this step will new keys be generated
                        </p>
                        <pre>
bin/signserver generatecertreq &lt;id&gt; "CN=Soft Signer token" SHA1WithRSA /tmp/certreq.pem
                        </pre>
                        <p>
Then upload the signing certificate  to the worker using the command:
                        </p>
                        <pre>
bin/signserver uploadsignercertificatechain &lt;id&gt; GLOB /tmp/cert.pem
                        </pre>
                        <p>
After the certificate chain has been uploaded to the server, the configuration must be reloaded and the SoftCryptoToken will be active and ready to use.
                        </p>
                    </subsubsection>
                </subsection>
            </section>
        </chapter>

        <chapter name="Development" shortname="development">
            <p>
This section describes the details of how to develop your own plug-ins for the SignServer API. It goes through most of the necessary interfaces to get going.
            </p>
            <section name="Building customized code">
                <p>
It is possible to have your own code in a separate code tree to avoid a mix of custom code with SignServer project code. This makes it easier to maintain and update the code for future versions. This is done by configuring one or more of the 'custom.' parameters in the build configuration file. The are each described here:
                </p>
                <p>
<b>custom.src.java</b> = Should point to an external directory containing the package base of the Java code. These are then included in the compilation at build time.
                </p>
                <p>
<b>custom.src.web</b> = Should point to the base of a WAR source tree with WEB-INF/web.xml included. This will replace the default WAR deployed during the build.
                </p>
                <p>
<b>custom.build.xml</b> = This can point to a custom build.xml that will be imported from the main build.xml and lets the developer include his own ant tasks if necessary.
                </p>
            </section>
            
            <section name="Custom modules">
                <p>
Custom code can be included in the SignServer build process by placing the projects under the modules directory and adhere to the modules contract.    
                </p>
                <p>
First, the property modules.build.includes in res/modules-project.properties defines which projects that should be included in the build process. All projects with a folder name starting with SignServer-Module-*, SignServer-ejb* or SignServer-war are included. Other patterns can be included by setting a property extra.modules.build.includes.
                </p>
                <p>
Second, in the project folder there should be an Ant script called build.xml.    
                </p>
                <p>
Third, if the project should be called it should define the properties:
                    <ul>
                        <li><b>modulename</b>: The name of the module. Will be used as prefix to the enable-property. Example: module.pdfsigner (the enable property will then be module.pdfsigner.enabled)</li>
                        <li><b>clean.available</b>: True if the "clean" target should be called when the rest of SignServer is getting cleaned.</li>
                        <li><b>dist-module.available</b>: True if the "dist-module" target should be called when SignServer is getting built</li>
                    </ul>
                    Example:
                </p>
                <pre>
&lt;property name="modulename" value="module.pdfsigner"/&gt;
&lt;property name="clean.available" value="true"/&gt;
&lt;property name="dist-module.available" value="true"/&gt;    
                </pre>
                <p>
Forth, the dist-module target should take care of moving all distributables to the ../../lib directory and if the module should be deployed as part of the signserver.ear file a module descriptor should be placed in ../../mods-available. The name of the descriptor file should be priority_modulename.properties where priority is the order in which the module should be built and modulename is the name as defined by the property with the same name.
                </p>
                <p>
The priorities are basically like this:
                    <ul>
                        <li>10: Essential core modules (like signserverejb and signservercommon)</li>
                        <li>20: Other core modules (like web services)</li>
                        <li>30: Other core modules (like web components etc)</li>
                        <li>40: Other modules (like signers/validators etc)</li>
                    </ul>
                </p>
                <p>
The module descriptor can contain:
                    <ul>
                        <li>module.name: Same as the modulename property</li>
                        <li>module.type: The type of the module. "lib" if the module should be put in signserver.ear/lib, "ejb" if it is an EJB module or "war" if it is and WAR module.</li>
                        <li>to.root: Comma separated list of files to move to the root of signserver.ear. Basedir is SIGNSERVER_HOME and all files should be taken from lib/ (not modules/ as it is not available in the binary distribution).</li>
                        <li>to.lib: Same as to.root but for jar files to be moved to signserver.ear/lib/.</li>
                        <li>module.ejb: Only if module.type is "ear" or "war". The name of the enterprise module file (example: signserver.war).</li>
                        <li>module.web.web-uri: Only if module.type is "war". The name to put in the web-uri part of the application.xml for this enterprise module.</li>
                        <li>module.web.context-root: Only if module.type is "war". The name to put in the context-root part of the application.xml for this enterprise module.</li>
                        <li>postprocess.files: Optionally. Comma separated list of property name prefixes for each file to postprocess (example: postprocess.file1)</li>
                        <li>postprocess.file1.src: Only if postprocess.files specified. Path of file to postprocess (relative to SIGNSERVER_HOME/lib/, example: SignServer-ejb-SignServerWS.jar)</li>
                        <li>postprocess.file1.includes: Only if postprocess.files. Ant includes pattern with files in the jar to postprocess (example: META-INF/ejb-jar.xml)</li>
                    </ul>
                    Example (mods-available/40_module.pdfsigner.properties):
                </p>
                <pre>
module.name=module.pdfsigner
module.type=lib
to.root=
to.lib=lib/ext/1.6/bcmail-jdk.jar,lib/ext/1.6/bcprov-jdk.jar,lib/ext/1.6/bctsp-jdk.jar,lib/ext/cert-cvc.jar,lib/ext/commons-collections-3.2.jar,lib/ext/commons-io-1.4.jar,lib/ext/commons-lang-2.4.jar,lib/ext/commons-logging.jar,lib/ext/ejbca-util.jar,lib/ext/log4j.jar,lib/ext/module/pdfsigner/itext/itext.jar,lib/SignServer-Common.jar,lib/SignServer-ejb-interfaces.jar,lib/SignServer-Module-PDFSigner.jar
                </pre>
                <p>
                Example (mods-available/20_signserverws.properties):    
                </p>
                <pre>
module.name=signserverws
module.type=ejb
module.ejb=SignServer-ejb-SignServerWS.jar
to.root=lib/SignServer-ejb-SignServerWS.jar
to.lib=lib/ext/1.6/bcmail-jdk.jar,lib/ext/1.6/bcprov-jdk.jar,lib/ext/1.6/bctsp-jdk.jar,lib/ext/cert-cvc.jar,lib/ext/commons-collections-3.2.jar,lib/ext/commons-io-1.4.jar,lib/ext/commons-lang-2.4.jar,lib/ext/commons-logging.jar,lib/ext/ejbca-util.jar,lib/ext/log4j.jar,lib/SignServer-Common.jar,lib/SignServer-ejb-interfaces.jar
postprocess.files=postprocess.file1
postprocess.file1.src=SignServer-ejb-SignServerWS.jar
postprocess.file1.includes=META-INF/ejb-jar.xml
                </pre>
            
            </section>
                    
           <section name="Custom CLI">
               <p>
                   In signserver_cli.properties:
               </p>
               <p>
<b>custom.commandfactory</b> = Should point to a custom implementation of the interface org.signserver.cli.ISignServerCommandFactory. This gives to ability to extend (or replace) the default CLI with another one. The best way of extending the CLI is to look at  how the DefaultSignServerCommandFactory  is structured.
                </p>
            </section>
            <section name="Plugin development">
                <p>
The main component in the SignServer is the Worker from which most other components inherits. To get a better overview of how the different component types relate to one and another see illustration 1 in the Overview section.
                </p>
                <p>
Most workers work in the same way but with different interfaces to implement but for all of them should the following steps be performed.
                </p>
                <ul>
                    <li>
Create a custom  class implementing the specified interface. There usually exists a base class implementing the most basic function to simply the implementation even further. If it exists it's recommended to inherit it.
                    </li>
                    <li>
You can define your own properties that the worker can use for its configuration.
                    </li>
                    <li>
Make sure the custom class is available to the application server
                    </li>
                    <li>
Redeploy the SignServer.
                    </li>
                    <li>
Register the worker in the application by setting a property WORKER&lt;id&gt;.CLASSPATH with a global scope in the global configuration. (Also make sure to set it's crypto tokens class-path, see separate section).
                    </li>
                    <li>
Reload the service with the CLI reload command.
                    </li>
                </ul>
                <subsection name="Implementing Workers">
                    <subsubsection name="The ISigner Interface">
                        <p>
A Signer is a component used to perform some form of cryptographic processing of requested data and to create a custom signer class it should  implement the org.signserver.server.signers.ISigner interface. There exists a BaseSigner that can be inherited taking care of some of the functionality. If the BaseSigner is inherited the only method that needs to be implemented is 'processData() '.
                        </p>
                        <p>
There exists a DummySigner implementation that is used for demonstration purposes.
                        </p>
                    </subsubsection>

                    <subsubsection name="The ITimedService Interface">
                        <p>
There are two kinds of timed services, singleton or non-singleton. A singleton service is only run at one of the nodes at the time while non-singleton services are run at all nodes simultaneously. If a singleton service fails to run on one of the nodes will one of the other nodes take over the service
automatically.
                        </p>
                        <p>
If a service should be singleton or not is determined by a standard property SINGLETON defined
in the ServiceConfig class.
                        </p>
                        <p>
Other basic properties used to configure all services are:
ACTIVE when set to "TRUE" means that the service is active and should be run.
INTERVAL defining the interval in seconds of how often the service should be run.
INTERVALMS defining the interval in milliseconds of how often the service should be run.
CRON used instead of INTERVAL or INTERVALMS to specify on a calendar basis.
                        </p>
                        <p>
To create a custom timed service class it should implement the org.signserver.server.timedservices.ITimedService interface. There exists a BaseTimedService that can be inherited taking care of most of the basic functionality. If the BaseTimedService is inherited the the only method that needs to be implemented is the 'work()' method.
                        </p>
                        <p>
The work method that needs to be implemented is described here:
                        </p>
                        <pre>
/**
 * Method that should do the actual work and should
 * be implemented by all services. The method is run
 * at a periodical interval defined in getNextInterval.
 *
 * @throws ServiceExecutionFailedException if execution of a service failed
 */
public void work() throws ServiceExecutionFailedException;
                        </pre>
                        <p>
There exists a DummyTimedService implementation that is used for demonstration purposes.
                        </p>
                    </subsubsection>

                    <subsubsection name="IValidationService Interface">
                        <p>
Just as the other worker plug-ins have the validator service a base class taking care of most of the common methods and the only method that needs to be implemented is the 'validate' method below. But for most applications should the DefaultValidationService work. What is probably more interesting is to develop a custom IValidator used to integrate the default validation service against different certificate status repositories. See section called 'Other Customizations' for details of how to implement a Validator.
                        </p>
                        <pre>
/**
 * Method used to check the validation of a certificate
 *
 * @param validationRequest
 * @return a ValidateResponse
 * @throws IllegalRequestException if data in the request didn't conform with the specification.
 * @throws CryptoTokenOfflineException if the crypto token isn't online.
 * @throws SignServerException for general failure exception during validation
 * @see org.signserver.validationservice.common.ValidateRequest
 * @see org.signserver.validationservice.common.ValidateResponse
 */
ValidateResponse validate(ValidateRequest validationRequest) throws IllegalRequestException, CryptoTokenOfflineException, SignServerException;
                        </pre>
                    </subsubsection>

                    <subsubsection name="IGroupKeyService Interface">
                        <p>
To customize a group key service is slightly more work. Then need five methods be implemented: 'fetchGroupKey', 'pregenerateGroupKeys', 'swithEncryptionKey', 'removeGroupKeys' and 'getStatus'. The default implementation stores the group keys in database with a reference to the encryption key used, the encryption key is stored in the extended key store. See the JavaDoc and the code for the default group key service for more details of implementing a customized one.
                        </p>
                        <pre>
/**
 * Main method of a Group Key Service responsible for fetching keys from
 * the database.
 *
 * @param fetchKeyRequest
 * @return a FetchKeyReponse
 * @throws IllegalRequestException if data in the request didn't conform with the specification.
 * @throws CryptoTokenOfflineException if the crypto token isn't online.
 * @throws SignServerException for general failure exception during key generation.
 * @see org.signserver.groupkeyservice.common.FetchKeyRequest
 * @see org.signserver.groupkeyservice.common.FetchKeyResponse
 */
FetchKeyResponse fetchGroupKey(FetchKeyRequest fetchKeyRequest) throws IllegalRequestException, CryptoTokenOfflineException, SignServerException;

/**
 * Method that instructs the group key service to pregenerate keys.
 * This method is called at periods when the server is having
 * a low load. This option is optional to implement, if the
 * service doesn't support this method it should return null.
 *
 *
 * @param pregenerateKeysRequest request data
 * @return a response containing number of keys generated, etc
 * @throws IllegalRequestException if requests contain unsupported data.
 * @throws CryptoTokenOfflineException if the crypto token isn't online.
 * @throws SignServerException for general failure exception during key generation.
 * @see org.signserver.groupkeyservice.common.PregenerateKeysRequest
 * @see org.signserver.groupkeyservice.common.PregenerateKeysResponse
 */
PregenerateKeysResponse pregenerateGroupKeys(PregenerateKeysRequest pregenerateKeysRequest) throws IllegalRequestException, CryptoTokenOfflineException, SignServerException;


/**
 * Method instructing the key service to switch the encryption key for
 * storing the group keys in the database. This to ensure that one encryption
 * key isn't exposed through to much data.
 *
 * This method is optional for the implementing service to implement, if
 * it's not implemented it should return null.
 *
 * @param switchEncKeyRequest request data.
 * @return a response containing the result of the operation such as new key index.
 * @throws IllegalRequestException if requests contain unsupported data.
 * @throws CryptoTokenOfflineException if the crypto token isn't online.
 * @throws SignServerException  for general failure exception during key generation.
 * @see org.signserver.groupkeyservice.common.SwitchEncKeyRequest
 * @see org.signserver.groupkeyservice.common.SwitchEncKeyResponse
 */
SwitchEncKeyResponse switchEncryptionKey(SwitchEncKeyRequest switchEncKeyRequest) throws IllegalRequestException, CryptoTokenOfflineException, SignServerException;

/**
 * Method instructing the key service to remove old group keys not used anymore
 * it up to the caller to check that the implementing service supports the type
 * of IRemoveGroupKeyRequest used. The request should contain data specifying which
 * keys that should be removed.
 *
 * This method is optional for the implementing service to implement, if
 * it's not implemented it should return null.
 *
 * @param removeGroupKeyRequests request data.
 * @return a response containing the result of the operation such as number of keys actually removed.
 * @throws IllegalRequestException if requests contain unsupported data.
 * @throws CryptoTokenOfflineException if the crypto token isn't online.
 * @throws SignServerException  for general failure exception during key generation.
 * @see org.signserver.groupkeyservice.common.RemoveGroupKeyResponse
 * @see org.signserver.groupkeyservice.common.IRemoveGroupKeyRequest
 */
RemoveGroupKeyResponse removeGroupKeys(IRemoveGroupKeyRequest removeGroupKeyRequests) throws IllegalRequestException, CryptoTokenOfflineException, SignServerException;


/**
 * Should return the actual status of the worker, status could be if
 * the signer is activated or not, or equivalent for a service.
 * @return a WorkerStatus object.
 */
public WorkerStatus getStatus();
                        </pre>
                    </subsubsection>
                </subsection>

                <subsection name="Implementing Crypto Tokens">
                    <subsubsection name="The ICryptoToken Interface">
                        <ul>
                            <li>
A custom crypto token needs to implement the interface org.signserver.server.cryptotokens.ICryptoToken.  See P12CryptoToken for an example implementation.
                            </li>
                            <li>
You can define own properties for a crypto token in the same way as for workers. The properties are sent to the crypto token upon initialization.
                            </li>
                            <li>
Make sure the custom class is available to the application server
                            </li>
                            <li>
Redeploy the SignServer.
                            </li>
                            <li>
Register the crypto token to a worker in the application by setting a property WORKER&lt;id&gt;.CRYPTOTOKEN.CLASSPATH with a global scope in the global configuration. (Also make sure to set it's crypto tokens class-path, see next section).
                            </li>
                            <li>
Reload the service with the CLI reload command.
                            </li>
                        </ul>
                        <p>
The ICryptoToken interface have the following methods that needs to be implemented:
                        </p>
                        <pre>
public interface ICryptoToken {
	public static final int PURPOSE_SIGN = 1;
	public static final int PURPOSE_DECRYPT = 2;

	public static final int PROVIDERUSAGE_SIGN    = 1;
	public static final int PROVIDERUSAGE_DECRYPT = 2;

   /**
    * Method called after creation of instance.
    *
    */
	public abstract void init(Properties props) throws CryptoTokenInitializationFailureException;

	/**
	 *  Method that returns the current status of the crypto token.
	 *
	 *  Should return one of the SignerStatus.STATUS_.. values
	 */
	public abstract int getCryptoTokenStatus();

    /**
     * Method used to activate SignTokens when connected after being off-line.
     *
     * @param authenticationcode used to unlock crypto token, i.e PIN for smartcard HSMs
     * @throws CryptoTokenOfflineException if SignToken is not available or connected.
     * @throws CryptoTokenAuthenticationFailureException with error message if authentication to crypto token fail.
     */
    public abstract void activate(String authenticationcode) throws CryptoTokenAuthenticationFailureException, CryptoTokenOfflineException;

    /**
     * Method used to deactivate crypto tokens.
     * Used to set a crypto token too off-line status and to reset the HSMs authorization code.
     *
     * @return true if deactivation was successful.
     */
    public abstract boolean deactivate();

    /** Returns the private key (if possible) of token.
    *
    * @param purpose should one of the PURPOSE_... constants
    * @throws CryptoTokenOfflineException if CryptoToken is not available or connected.
    * @return PrivateKey object
    */
    public abstract PrivateKey getPrivateKey(int purpose) throws CryptoTokenOfflineException;

    /** Returns the public key (if possible) of token.
    *
    * @param purpose should one of the PURPOSE_... constants
    * @throws CryptoTokenOfflineException if CryptoToken is not available or connected.
    * @return PublicKey object
    */
    public abstract PublicKey getPublicKey(int purpose) throws CryptoTokenOfflineException;


    /** Returns the signature Provider that should be used to sign things with
     *  the PrivateKey object returned by this crypto device implementation.
     *  @param providerUsage should be one if the ICryptoToken.PROVIDERUSAGE_ constants
     *  specifying the usage of the private key.
     * @return String the name of the Provider
     */
    public abstract String getProvider(int providerUsage);

    /**
     * Method returning the crypto tokens certificate if it's included in the token.
     * This method should only be implemented by soft crypto tokens which have the certificate
     * included in the key store.
     *
     * All other crypto tokens should return 'null' and let the signer fetch the certificate from database.
     *
     */

    public abstract Certificate getCertificate(int purpose) throws CryptoTokenOfflineException;


    /**
     * Method returning the crypto tokens certificate chain if it's included in the token.
     * This method should only be implemented by soft crypto tokens which have the certificates
     * included in the key store.
     *
     * All other crypto tokens should return 'null' and let the signer fetch the certificate from database.
     *
     */

    public abstract Collection&lt;Certificate&gt; getCertificateChain(int purpose) throws CryptoTokenOfflineException;

	/**
	 * Method used to tell the crypto token to create a certificate request using its crypto token.
	 */
	public ICertReqData genCertificateRequest(ISignerCertReqInfo info) throws CryptoTokenOfflineException;

	/**
	 * Method used to remove a key in the signer that shouldn't be used any more
	 * @param purpose on of ICryptoToken.PURPOSE_ constants
	 * @return true if removal was successful.
	 */
	public boolean destroyKey(int purpose);
}
                        </pre>
                    </subsubsection>

                    <subsubsection name="The Extended Crypto Token Interface">
                        <p>
The default group key service need support for symmetric keys in addition the the functionality provided in the basic crypto token which mainly focuses on asymmetric key functionality.
                        </p>
                        <p>
The extended crypto token adds four more methods that need implementation used to generate exportable keys (symmetric or asymmetric) and to encrypt/decrypt data using symmetric keys.
                        </p>
                        <pre>
public interface IExtendedCryptoToken extends ICryptoToken {

	/**
	 * Method instructing the crypto token to generate a key that is returned
	 *
	 * @param keyAlg the key algorithm to generate, it's up to the caller to check that the crypto token
	 * used supports the given value.
	 * @param keySpec specification of the key, it's up to the caller to check that the crypto token
	 * used supports the given value.
	 * @return either a java.security.Key or a java.security.KeyPair depending on type of keyAlg sent to the the crypto token.
	 * @throws IllegalRequestException if the token doesn't support the given key alg or key spec.
	 * @throws CryptoTokenOfflineException if the token isn't online.
	 */
	Serializable genExportableKey(String keyAlg, String keySpec) throws IllegalRequestException, CryptoTokenOfflineException;

	/**
	 * Instructs the crypto token to generate a key stored in the device returning only
	 * a alias reference to the key.
	 *
	 * @param keyAlg the key algorithm to generate, it's up to the caller to check that the crypto token
	 * @param keySpec keySpec specification of the key, it's up to the caller to check that the crypto token
	 * used supports the given value.
	 * @return a reference to the key in that can be used later for encryption/decryption.
	 *
	 * @throws IllegalRequestException if the token doesn't support the given key alg or key spec.
	 * @throws CryptoTokenOfflineException if the token isn't online.
	 */
	String genNonExportableKey(String keyAlg, String keySpec) throws IllegalRequestException,  CryptoTokenOfflineException;

	/**
	 * Method used to encrypt data using a key stored in the crypto token. This
	 * method should mainly be used for symmetric encryption.
	 * @param keyRef a alias reference to the key that should be used.
	 * @param data the data to encrypt.
	 * @return the encrypted data.
	 * @throws CryptoTokenOfflineException if the token isn't online.
	 */
	byte[] encryptData(String keyRef, byte[] data) throws CryptoTokenOfflineException;

	/**
	 * Method used to decrypt data using a key stored in the crypto token. This
	 * method should mainly be used for symmetric encryption.
	 * @param keyRef a alias reference to the key that should be used.
	 * @param data the data to decrypt.
	 * @return the encrypted data.
	 * @throws CryptoTokenOfflineException if the token isn't online.
	 */
	byte[] decryptData(String keyRef, byte[] data) throws CryptoTokenOfflineException;


}
                        </pre>
                    </subsubsection>
                </subsection>
            </section>

            <section name="Other Customizations">
                <subsection name="The IValidator Interface">
                    <p>
A Validator is used in the DefaultValidationService to connect to different kinds of certificate status repositories, such as CRL, OCSP, XKMS, database etc. It contains two methods 'validate' used for the actual certificate validation and 'testConnection' used by health check related functionality to check that the connection to the underlying validator resource is alright.
                    </p>
                    <pre>
/**
 * Main method of a Validation Service responsible for validating certificates.
 *
 * Important a validator also have to support to check the revocation status of the
 * involved CA certificates and should only return Validation object with status REVOKED or VALID
 * If the validator doesn't support the given issuer it must return null.
 *
 *
 * @param cert the certificate to validate.
 * @return a Validation object or null if the certificate couldn't be looked up in this validator.
 * @throws IllegalRequestException if data in the request didn't conform with the specification.
 * @throws CryptoTokenOfflineException if the crypto token isn't online.
 * @throws SignServerException for general failure exception during validation.
 */
Validation validate(ICertificate cert) throws IllegalRequestException, CryptoTokenOfflineException, SignServerException;






/**
 * Optional method used to test the connection to a specific underlying validator implementation.
 *
 * @throws ConnectException if connection to underlying validator implementation failed.
 * @throws SignServerException for general failure exception during validation.
 */
void testConnection() throws ConnectException, SignServerException;
                    </pre>
                </subsection>

                <subsection name="The IAuthorizer Interface">
                    <p>
It's possible to integrate the authorization of processable requests with external authorizations applications. All that is needed is a class implementing the IAuthorizer interface containing two methods, 'init' and 'isAuthorized'.
                    </p>
                    <p>
To register that the customized authorizer should be used by a worker, all that's needed to be done is to set the property AUTHTYPE to the class path of the authorizer implementation.
                    </p>
                    <pre>
public interface IAuthorizer {

	/**
	 * Method called by the worker upon first call to the authenticator after instantiation.
	 *
	 * @param workerId id of worker.
	 * @param config active worker configuration of worker
	 * @param em the SignServer EntityManager
	 * @throws SignServerException if unexpected error occurred during initialization.
	 */
	void init(int workerId, WorkerConfig config, EntityManager em) throws SignServerException;

	/**
	 *
	 * Main method determining if the requester is authorized to process the data in the request.
	 *
	 * @param request the request data sent to the worker to process.
	 * @param requestContext containing the optional clientCert client certificate or remote IP of the user, may also contain customly defined data.
	 * @throws SignServerException if unexpected error occurred during authorization.
	 * @throws IllegalRequestException if the requester isn't authorized or couldn't be authenticated for some other reason.
	 */
	void isAuthorized(ProcessRequest request, RequestContext requestContext) throws IllegalRequestException, SignServerException;
}
                    </pre>
                </subsection>
                
                <subsection name="The Archiving API">
                    <p>
Custom ArchiverS can be implemented by implementing the Archiver interface. See 
org.signserver.server.archive.Archiver.
                    </p>
                    <p>
                        <a href="../images/archivingapi.png"><img src="../images/archivingapi.png" align="middle" border="1" width="603" height="323" alt="Archiving API"/></a>
                    </p>
                </subsection>

                <subsection name="Using the Global Configuration Store">
                    <p>
The global configuration store is a memory bank that workers can use to store data used
in ongoing operations. The data can be either node (i.e. only read by the current node) or global
scoped.
                    </p>
                    <p>
To access the global configuration store use the getGlobalConfigurationSession() method
from the BaseWorker (inherited by most of the base component implementations). The returned
GlobalConfigurationSession have the following methods that can be used (the other ones should be
avoided)
                    </p>
                    <pre>
/**
* Method setting a global configuration property. For node. prefix will the
node id be appended.
* @param scope, one of the GlobalConfiguration.SCOPE_ constants
* @param key of the property should not have any scope prefix, never null
* @param value the value, never null.
*/
public void setProperty( java.lang.String scope,java.lang.String
key,java.lang.String value ) ;
/**
* Method used to remove a property from the global configuration.
* @param scope, one of the GlobalConfiguration.SCOPE_ constants
* @param key of the property should start with either glob. or node., never
null
* @return true if removal was successful, othervise false.
*/
public boolean removeProperty( java.lang.String scope,java.lang.String key )
;
/**
* Method that returns all the global properties with Global Scope and Node
scopes properties for this node.
* @return A GlobalConfiguration Object, nevel null
*/
public org.signserver.common.GlobalConfiguration getGlobalConfiguration( ) ;
                    </pre>
                    <p>
The getGlobalConfiguration returns a GlobalConfiguration and have a method
String getProperty(String scope, String property) that can be used.

The value of the property can be user-defined as long as it is guaranteed to be unique over the entire
application.

Reserved values are all property keys starting with "WORKER".
                    </p>
                </subsection>
            </section>


            <section name="Testing">
                <p>
                    There exists some test scripts used to test that the SignServer functions correctly. They are described here.
                </p>

                <subsection name="Automatic JUnit Tests">
                    <p>
Automatic JUnit tests are in the different projects and system tests in SignServer-Test-System.
                    </p>
                    <p>
Important: For the SignServer test suite to run successful the following 
properties should be set in signserver_build.properties:
                    <ul>
                        <li>signserverws.enabled=true</li>
                        <li>genericws.enabled=true</li>
                        <li>validationws.enabled=true</li>
                        <li>adminws.enabled=true</li>
                        <li>timestampclient.enabled=true</li>
                        <li>validationclient.enabled=true</li>
                        <li>signingandvalidationapi.enabled=true</li>
                        <li>clientcli.enabled=true</li>
                        <li>includemodulesinbuild=true</li>
                        <li>useclusterclassloader=true</li>
                        <li>clusterclassloader.useclassversions=true</li>
                    </ul>
                    </p>
                    <p>
To run the test suite do the following:
                    </p>
                    <ul>
<li>Set the environment variable SIGNSERVER_HOME</li>
<li>Make sure SignServer is deployed and the application server is running</li>
<li>Do 'ant test:run'</li>
<li>A protocol is generated in the directory 'bin/junit'</li>
                    </ul>
                    <p>
A single system test can be run with "ant test:runone -Dtest.runone=ClassName" 
where ClassName is replaced with the test class to run.
                    </p>
                    <p>
A single test can also be run the same way from any of the other projects that 
has tests by executing the command from their project directory.
                    </p>
                </subsection>

                <subsection name="Testing the TimeStamp Authority">
                    <subsubsection name="The TSA Test Client">
                        <p>
There exists a Time Stamp Authority test client that is built with the main distribution. For other workers it's recommended to test it with the WS CLI client described in the 'Main WebService' section.
                        </p>
                        <p>
It only works without client authentication requirements and through HTTP.
                        </p>
                        <p>
To run the client do
                        </p>
                        <pre>
bin/client timestamp "http://&lt;hostname&gt;:8080/signserver/tsa?signerId=1"
                        </pre>
                        <p>
It will continuously make one request per second. Run the test client without arguments to get a list of possible arguments, you can use it as a full time stamp client to get real document time stamps.
                        </p>
                        <pre>
java -jar timeStampClient.jar
 -instr &lt;string&gt;      String to be time stamped, if neither instr or
                      infile is given, the client works in test-mode generating it's own
                      message.
 -base64              Give this option if the stored request/reply should
                      be base64 encoded, default is not.
 -help                Print this message.
 -infile &lt;file&gt;       File containing message to time stamp.

...snip...
                        </pre>
                    </subsubsection>

                    <subsubsection name="Manual Tests">
                        <p>
The time stamp signer have been tested with the OpenTSA client with both HTTP and HTTPS.
                        </p>
                    </subsubsection>
                </subsection>
            </section>
        </chapter>

        <chapter name="Miscellaneous" shortname="misc">

            <section name="Timed Services">
                <p>
A Timed Service (formerly called just service) is a task that is run on a timely basis, performing maintenance tasks like changing active key, or it could generate a report.
                </p>
                <p>
A Timed Service framework supports a couple basic properties that is used to calculate when and how a timed service should run. These properties are:
                </p>
                <p>
<b>ACTIVE</b> =  "TRUE" if the service should be run, otherwise it is disabled.
                </p>
                <p>
<b>SINGLETON</b> =  "TRUE" if the service only should be run on one of the nodes in the cluster at the time. If it's not set or set to FALSE is the service run simultaneously on all nodes in the cluster. If the node running a singleton service fails will another node sense this and start up the service.
                </p>
                <p>
<b>INTERVAL</b> = Property defining the interval in seconds the service should run.
                </p>
                <p>
<b>INTERVALMS</b> = Property defining the interval in milliseconds the service
should run. Notice that the platform and application server might put a lower
bound on the value. The lower limit for GlassFish is by default 7000 milliseconds
but can be changed by editing minimum-delivery-interval-in-millis in domain.xml.
                </p>
                <p>
<b>CRON</b> = Property that should define a CRON expression of how often the service should run.  It should conform to Unix CRON standard. (One and only one of INTERVAL, INTERVALMS or CRON is required)
                </p>

                <subsection name="SignerStatusReportTimedService">
                    <subsubsection name="Overview">
                        <p>
The SignerStatusReportTimedService is a timed service that outputs status for a
set of workers to a file. The information includes each workers crypto token status
ACTIVE/OFFLINE and if available also the numbers of signatures that has been
performed with the key currently associated with the worker. If the worker has
a configured limit of number of signatures, this value is also included.
                        </p>
                        <p>
<b>Format:</b>
                        </p>
                        <pre>
workerName=WORKERNAME1, status=STATUS1, KEY3=VALUE3, KEY4=VALUE4, ...
workerName=WORKERNAME2, status=STATUS2, KEY3=VALUE3, KEY4=VALUE4, ...
workerName=WORKERNAME3, status=STATUS3, KEY3=VALUE3, KEY4=VALUE4, ...
...
                        </pre>
                        <p>
<b>Rules:</b>
<ul>
    <li>Each line contains a set of properties for one worker.</li>
    <li>Lines are separated by a system dependent newline character (CR,
LF or CRLF).</li>
    <li>Properties are of form KEY=VALUE and are separated by a comma and a
space (", ").</li>
    <li>The properties "workerName" and "status" are the only ones that must be
present.</li>
    <li>The property "workerName" is always the first property.</li>
</ul>
                        </p>
                        <p>
<b>Properties:</b>
<ul>
    <li><b>workerName</b>: name of the worker. Example: "sod71" or "sod72"</li>
    <li><b>status</b>: status of the worker's crypto token and key. Either
"ACTIVE" or "OFFLINE".</li>
    <li><b>validityNotBefore</b>: the first date the signer is allowed to sign.
Format is java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss z").</li>
    <li><b>validityNotAfter</b>: the last date the signer is allowed to sign.</li>
    <li><b>signings</b>: the number of signatures that has been performed with the key
used by this worker.</li>
    <li><b>signLimit</b>: the maximum number of signatures this worker is allowed
to perfom or -1 if there is no limit.</li>
</ul>
                        </p>
                        <p>
<b>Examples:</b>
                        </p>
                        <pre>
workerName=Sod71, status=ACTIVE, validityNotBefore=2010-07-05 17:32:36 CEST, validityNotAfter=2010-09-08 17:32:36 EEST, signings=132, signLimit=100000,
workerName=Sod72, status=OFFLINE, validityNotBefore=2010-07-05 17:32:33 CEST, validityNotAfter=2010-09-08 17:32:33 EEST, signings=100000, signLimit=100000,
workerName=Sod73, status=OFFLINE, validityNotBefore=2010-07-05 17:32:33 CEST, validityNotAfter=2010-09-08 17:32:33 EEST, signings=0, signLimit=100000,
workerName=Sod74, status=OFFLINE,
                        </pre>
                        <p>
<b>Examples explained:</b>
                        </p>
                        <p>
Sod71 has done 132 signings and is ACTIVE and validityNotAfter indicates
that it can continue to sign until 8th September if not the sign limit
is reached before
                        </p>
                        <p>
Sod72 has performed all of its 100000 signings and can not sign until it
gets a new key and certificate.
                        </p>
                        <p>
Sod73 has not reached its limit and is still in validity time but is
OFFLINE for some other reason.
                        </p>
                        <p>
Sod74 is OFFLINE and has no certificate configured.
                        </p>
                    </subsubsection>
                    <subsubsection name="Available Properties">
<p><b>WORKERS</b> = Comma separated list of worker names (signers) that should
be monitored.</p>
<p><b>OUTPUTFILE</b> = File that the information will be written to. If the file
exists the content will be overwritten. The application server needs to have write
access to this file when the service is executed.

                        </p>
                    </subsubsection>
                    
                </subsection>
                <subsection name="Installing a service">
                    <p>To install a service you use the same commands as for installing a worker:</p>
                    <source>
$ bin/signserver setproperties configuration.properties
                    </source>
                    <p>Example:</p>
                    <source>
$ bin/signserver setproperties doc/sample-configs/qs_signerstatusreport_configuration.properties
===========================================
  Executing Command on host : localhost
===========================================
Configuring properties as defined in the file : doc/sample-configs/qs_signerstatusreport_configuration.properties
Setting the property ACTIVE to TRUE for worker 2
Setting the property INTERVAL to 10 for worker 2
Setting the global property WORKER2.CLASSPATH to org.signserver.server.timedservices.SignerStatusReportTimedService with scope GLOB.
Setting the property WORKERS to PDFSigner1 for worker 2
Setting the property NAME to SignerStatusReporter for worker 2
Setting the property OUTPUTFILE to /tmp/statusreport for worker 2

$ bin/signserver reload 2
===========================================
Executing Command on host : localhost
===========================================
SignServer reloaded successfully
Current configuration is now activated.
                    </source>
                </subsection>
            </section>

            <section name="The Global Configuration Store">
                <p>
The available workers and its crypto tokens and services is configured in something called the global configuration store that is slightly different from a worker configuration.
                </p>
                <p>
Is is dynamically configured and activated immediately. I can contain any type of data (in string representation) and can be of two types, either with global scope or node scope. A Global scoped property can be accessed by  all nodes in the cluster while a Node scoped property in only used within a node and cannot be accessed by the other nodes.
                </p>
                <subsection name="SignServer specific">
                    <p>
Database failure is handled differently. If a node looses connection to the database it put itself in a state called 'unsynchronised' and will continue its operation without storing the data to database by using a cached global configuration. It is possible to later resynchronise one nodes cached global configuration data  with the database with a CLI command called 'resync'. But it is only possible to sync one of the nodes global configuration to the database.
                    </p>
                </subsection>
            </section>

            <section name="Status Repository">
                <p>
The status repository holds local (per JVM) status information (properties)
with optional expiration times. After the expiration time the property is not
returned.
                </p>
                <p>
This could be used by having workers read status from the repository while it
is an external service updating it.
                </p>
            </section>

            <section name="Logging">
                <p>
SignServer uses Log4j for logging and there are a few different loggers
available where the first two can be useful for audit logging:
                </p>
                <ul>
                    <li>Worker Log (org.signserver.server.log.IWorkerLogger)</li>
                    <li>System Log (org.signserver.server.log.ISystemLogger)</li>
                    <li>Debug Log (any other class name)</li>
                </ul>
                <subsection name="Worker Log">
                    <p>
The purpose of the Worker Loggers are to log each transaction handled by the
worker. Each worker can choose to have its own configuration for the logger. By
default the AllFieldsWorkerLogger is used which used logs all the available
fields one after each other separated by semi colons.
                    </p>
                    <p>
Which Worker Logger configuration to use is configured by setting the
<b>WORKERLOGGER</b> property to the full class name of the IWorkerLogger
implementation in the worker's configuration. Examples:
                    </p>
                    <source>
WORKERLOGGER=org.signserver.server.log.AllFieldsWorkerLogger
                    </source>
                    <source>
WORKERLOGGER=org.signserver.module.tsa.CustomTimeStampLogger1
                    </source>
                    <source>
WORKERLOGGER=org.signserver.server.log.PatternWorkerLogger
LOGTIMEZONE=GMT
LOGDATEFORMAT=yyyy-MM-dd:HH:mm:ss:z
LOGPATTERN=\$\{(.+?)\}
LOGORDER=AUDIT; LOG_ID: ${LOG_ID}; CLIENT_IP: ${CLIENT_IP}; REQUEST_FULLURL: ${REQUEST_FULLURL}; RequestTime: ${LOG_TIME}; ResponseTime: ${REPLY_TIME}; EXCEPTION: ${EXCEPTION};
                    </source>
                </subsection>
                <subsection name="System Log">
                    <p>
The System Logger is instead for logging all other audit events that are not
associated with a particular worker. The default System Logger is the
AllFieldsSystemLogger that logs all the available fields one after each other
separated by semi colons.
                    </p>
                </subsection>
                <subsection name="Debug Log">
                    <p>
The debug log is just the normal log that can be useful for finding out
configuration problems etc.
                    </p>
                </subsection>

                <subsection name="Configure Log4j for Audit logs">
                    <p>
For JBoss you can configure JBOSS_HOME/server/default/conf/jboss-log4j.xml to
put the audit logs in a separate file.
                    </p>
                    <source>
&lt;appender name="SIGNSERVER_AUDIT" class="org.jboss.logging.appender.DailyRollingFileAppender"&gt;
    &lt;errorHandler class="org.jboss.logging.util.OnlyOnceErrorHandler"/&gt;
    &lt;param name="File" value="${jboss.server.log.dir}/signserver_audit.log" /&gt;
    &lt;param name="Append" value="true" /&gt;

    &lt;!-- Rollover at midnight each day --&gt;
    &lt;param name="DatePattern" value="'.'yyyy-MM-dd" /&gt;
    &lt;layout class="org.apache.log4j.PatternLayout"&gt;
        &lt;param name="ConversionPattern" value="%d %-5p [%c] %m%n" /&gt;
    &lt;/layout&gt;
&lt;/appender&gt;

&lt;category name="org.signserver.server.log.ISystemLogger"&gt;
    &lt;appender-ref ref="SIGNSERVER_AUDIT"/&gt;
&lt;/category&gt;
&lt;category name="org.signserver.server.log.IWorkerLogger"&gt;
    &lt;appender-ref ref="SIGNSERVER_AUDIT"/&gt;
&lt;/category&gt;
                    </source>
                </subsection>

            </section>

            <section name="Installation Packages">
                <p>
From version 3.1 and upwards will there be binary installation packages released alongside the regular source packages. The packages includes all software necessary except for Java, were JDK 1.6+ is required.
                </p>
                <p>
At the current moment are the platforms Linux (mainly Debian distribution is tested but it should work for other distributions as well) and Windows XP/2003 supported. The SignServer have two packages, one server part that should be installed in every node in the cluster and one management package containing the CLI.
                </p>
                <subsection name="Using the Installation Packages">
                    <p>
The installation package can be used either by using a GUI or on the command line by specifying the argument '-mode text'
                    </p>
                    <p>
For an advanced set-up, for instance if many nodes should be installed with similar configuration, it is possible to preconfigure the installation by specifying a properties file containing some or all the properties asked during the installation. The properties will be used directly during installation and there will be no questions about it. See each package section for details about supported properties.
                    </p>
                    <p>
The configuration file should be in the following locations:
                    </p>
                    <pre>
Unix SignServer Installation            : /etc/signserver/signserver.conf
Windows SignServer Installation         : %SYSTEMROOT%\signserver.conf
                                         (i.e C:\WINDOWS\signserver.conf)
                    </pre>
                    <p>
After installation will all the settings be saved to the configuration file by the installation program to simplify re-installation.
                    </p>
                    <p>
If all necessary properties is given in the property file, it's possible to install the package silently by specifying '--mode unattended' on the command line.
                    </p>
                    <subsubsection name="SignServer Node">
                        <p>
The server part of the SignServer package contains everything (except Java) that is needed to set-up a node in a cluster. It contains a preconfigured version of JBoss that is ready to use.
                        </p>
                        <p>
The steps performed during the installation process are:
                        </p>
                        <p>
	Unix:
                        </p>
                        <ul>
                            <li>
By default is everything unpacked in /opt/signserver-&lt;version&gt; .
                            </li>
                            <li>
If a /etc/signserver/signserver.conf file exists, it's read and used during installation.
                            </li>
                            <li>
The user and group 'signserver' is created
                            </li>
                            <li>
JBoss init.d script is configured to run at runlevel 3,4,5
                            </li>
                            <li>
Directory /etc/signserver/ is created to contain all configuration files
                            </li>
                            <li>
Database configuration file /etc/signserver/database-conf.xml is populated.
                            </li>
                            <li>
Log configuration file /etc/signserver/log-conf.xml is populated and configured to log to the directory /var/log/signserver
                            </li>
                            <li>
If no HTTP SSL certificate is specified in the configuration file will dummy key stores be generated to /etc/signserver.
                            </li>
                            <li>
Tomcat is configured for HTTPS and it's configuration file is placed in /etc/signserver/webserver-conf.xml
                            </li>
                            <li>
Finally is Jboss started and ready to be used.
                            </li>
                        </ul>
                        <p>
	Windows:
                        </p>
                        <ul>
                            <li>
By default is everything unpacked in C:\Program\SignServer\SignServer-&lt;version&gt; .
                            </li>
                            <li>
If a c:\WINDOWS\signserver.conf file exists it's read and used during installation.
                            </li>
                            <li>
JBoss is configured to be run as a service that is started automatically.
                            </li>
                            <li>
Database configuration file &lt;INSTALLDIR&gt;\database-conf.xml is populated.
                            </li>
                            <li>
Log configuration file &lt;INSTALLDIR&gt;\log-conf.xml is populated and configured to log to the default directory &lt;INSTALLDIR&gt;\jboss\server\default\log
                            </li>
                            <li>
If no HTTP SSL certificate is specified will dummy key stores be generated to &lt;INSTALLDIR&gt;
                            </li>
                            <li>
Tomcat is configured for HTTPS and it's configuration file is placed in &lt;INSTALLDIR&gt;\webserver-conf.xml
                            </li>
                            <li>
Finally is Jboss started and ready to be used.
                            </li>
                        </ul>
                        <p>
The supported properties in the configuration file /etc/signserver/signserver.conf (or %SYSTEMROOT%\signerserver.conf for windows) are:
                        </p>
                        <table>
                            <tr><th>Property Name</th><th>Description</th><th>Example value</th><th>Where to manually reconfigure </th></tr>
                            <tr><td>SIGNSERVER_NODEID</td><td>A unique string value (containing alphanumeric characters only) identifying the node in a cluster.</td><td>node1</td><td>Unix: /etc/signserver/signserver.conf<br/>Windows:<br/>%Systemroot%\signserver.conf</td></tr>
                            <tr><td>database.type</td><td>Type of database, currently are Hypersonic, Mysql, Mysql Cluster, Postgres and MS SQL 2000 supported</td><td>hsqldb, mysql, mysqlndb,  postgres, mssql2000</td><td>Unix:<br/>/etc/signserver/database-conf.xml<br/>Windows: %Installdir%\database-conf.xml</td></tr>
                            <tr><td>database.hosts</td><td>The hostnames of the databases used. (not used for hsqldb).</td><td>localhost</td><td>Unix:<br/>/etc/signserver/database-conf.xml<br/>Windows: %Installdir%\database-conf.xml</td></tr>
                            <tr><td>database.port</td><td>The port of the database (not used for hsqldb).</td><td>1433</td><td>Unix:<br/>/etc/signserver/database-conf.xml<br/>Windows: %Installdir%\database-conf.xml</td></tr>
                            <tr><td>database.name</td><td>The name of the database  (not used for hsqldb).</td><td>signserver</td><td>Unix:<br/>/etc/signserver/database-conf.xml<br/>Windows: %Installdir%\database-conf.xml</td></tr>
                            <tr><td>database.username</td><td>The username used for authentication against the database (not used for hsqldb).</td><td>signserver</td><td>Unix:<br/>/etc/signserver/database-conf.xml<br/>Windows: %Installdir%\database-conf.xml</td></tr>
                            <tr><td>database.password</td><td>The password used for authentication against the database (not used for hsqldb).</td><td>foo123</td><td>Unix:<br/>/etc/signserver/database-conf.xml<br/>Windows: %Installdir%\database-conf.xml</td></tr>
                            <tr><td>httpserver.hostname</td><td>Hostname used as CN in generated SSL Server certificate.</td><td>host1.someorg</td><td>Only used during the of SSL Server certificate generation phase of installation.</td></tr>
                            <tr><td>httpserver.storepath</td><td>Path to the key store (JKS file) containing the SSL server certificate.</td><td>/etc/signserver/tomcat.jks</td><td>Unix:<br/>/etc/signserver/webserver-conf.xml<br/>Windows: %Installdir%\webserver-conf.xml</td></tr>
                            <tr><td>httpserver.password</td><td>Password to unlock the SSL server certificate key store.</td><td>foo123</td><td>Unix:<br/>/etc/signserver/webserver-conf.xml<br/>Windows: %Installdir%\webserver-conf.xml</td></tr>
                            <tr><td>httptrust.storepath</td><td>Path to the key store (JKS file) containing the CA trust store.</td><td>/etc/signserver/truststore.jks</td><td>Unix:<br/>/etc/signserver/webserver-conf.xml<br/>Windows: %Installdir%\webserver-conf.xml</td></tr>
                            <tr><td>httptrust.password</td><td>Password unlocking the CA truststore.</td><td>foo123</td><td>Unix:<br/>/etc/signserver/webserver-conf.xml<br/>Windows: %Installdir%\webserver-conf.xml</td></tr>
                            <tr><td>syslog.hostname</td><td>Host name of the Syslog server. This setting also indicates that Syslog should be used.</td><td>loghost.someorg.org</td><td>Unix:<br/>/etc/signserver/log-conf.xml<br/>Windows: %Installdir%\log-conf.xml</td></tr>
                        </table>
                    </subsubsection>

                    <subsubsection name="SignServer Management">
                        <p>
This package installs the CLI interface on the management station (which can be the same as a node). The following steps are performed during installation:
                        </p>
                        <p>
	Unix:
                        </p>
                        <ul>
                            <li>By default is everything unpacked in /opt/signserver-&lt;version&gt; .</li>
                            <li>If a /etc/signserver/signserver.conf file exists it's read and used during installation.</li>
                            <li>The user and group 'signserver' is created</li>
                            <li>A link from /opt/signserver-&lt;version&gt;/bin/signserver is done to /usr/local/bin.</li>
                        </ul>
                        <p>
	Windows:
                        </p>
                        <ul>
                            <li>Everything is unpacked in C:\Program\SignServer\SignServer-&lt;version&gt; by default.</li>
                            <li>If a c:\WINDOWS\signserver.conf file exists it's read and used during installation.</li>
                        </ul>
                        <p>
The signserver.conf supports the following settings:
                        </p>
                        <table>
                            <tr><th>Property Name</th><th>Description</th><th>Example value</th><th>Where to manually reconfigure </th></tr>
                            <tr><td>hostname.masternode</td><td> Hostname of master node in the cluster.</td><td>node1.someorg.org</td><td>Unix:<br/>/etc/signserver/signserver.conf<br/>Windows: %Installdir%\signserver.conf</td></tr>
                            <tr><td>hostname.allnodes</td><td>Hostname of all hosts in cluster, separated by ';'. </td><td>node1.someorg.org;node2.someorg.org</td><td>Unix:<br/>/etc/signserver/signserver.conf<br/>Windows: %Installdir%\signserver.conf</td></tr>
                        </table>
                    </subsubsection>
                </subsection>

                <subsection name="Generating Installation Packages">
                    <p>
Before generating a installation package must Bitrock InstallBuilder be installed on a Linux workstation. Then set the build mode in signserver_build.properties and go to src/install/bitrock. If a SignServer package should be generated must the environment variable JBOSS_PREP point the a prepared JBoss installation that will be included in the package.
                    </p>
                    <p>
Then execute the script './buildsignserverpkgs.sh &lt;version&gt;' to start the generation process. The packages will be generated in BitRocks default output directory.
                    </p>
                </subsection>
            </section>

            <section name="References">
                <ul>
                    <li>Java  (<a href="http://java.sun.com">http://java.sun.com</a>)</li>
                    <li>JBoss  (<a href="http://www.jboss.org">http://www.jboss.org</a>)</li>
                    <li>Apache Ant (<a href="http://ant.apache.org">http://ant.apache.org</a>)</li>
                    <li>Bouncycastle (<a href="http://www.bouncycastle.org">http://www.bouncycastle.org</a>)</li>
                    <li>RFC3161, Time-Stamp Protocol (TSP) (<a href="http://www.ietf.org">http://www.ietf.org</a>)</li>
                </ul>
            </section>
            
        </chapter>

        <chapter name="How To" shortname="howto">
            <section name="Setting up an Apache Web Server as a proxy in front of SignServer">
                <p>
This section will show you how to use an Apache Web Server Proxy in front of SignServer.
                <br/>The resulting server will
                </p>
                <ul>
                <li>Make the TSA available through the nice url http://tsa.company.com/</li>
                </ul>
                <p>
This example was created on Ubuntu 64-bit Server 8.10 using the Apache Web Server 2.2 package,
but should be easy to adapt to any system able to run Apache.
                </p>
                <p>
Start by installing SignServer as normal. If you intend to have the CA on the same machine as
the proxy you should modify $SIGNSERVER_HOME/signserver_build.properties to only listen to localhost
                </p>
<source>
httpsserver.bindaddress.pubhttp=127.0.0.1
httpsserver.bindaddress.pubhttps=127.0.0.1
httpsserver.bindaddress.privhttps=127.0.0.1
</source>
                <p>
Install the Apache web server and enable required modules:
                </p>
<source>
$sudo su
#apt-get install apache2
#cd /etc/apache2/mods-enabled/
#ln -s ../mods-available/proxy.load proxy.load
#ln -s ../mods-available/proxy_http.load proxy_http.load
#ln -s ../mods-available/rewrite.load rewrite.load
</source>
                <p>
A sample configuration how to fix up nice URLs for OCSP so that you can point your TSA clients to http://tsa.company.com/ instead of http://tsa.company.com:8080/signserver/process?workerId=1.
                <br/>
This configuration combines mod_proxy with mod_rewrite to be able to set the workerName or workerId, so you can have different TSAs available on different URLs.
                </p>
<source>
&lt;VirtualHost tsa.company.com:80>
ServerName tsa.company.com
ServerAlias tsa.company.com
CustomLog /var/log/apache2/access.log combined

RewriteEngine on
RewriteLogLevel 5
RewriteLog "/var/log/apache2/rewrite.log
RewriteRule ^/$ /?workerName=TSA [PT]

ProxyRequests Off
&lt;Proxy *>
  Order deny,allow
  Allow from all
&lt;/Proxy>
ProxyPass / http://127.0.0.1:8080/signserver/process
ProxyPassReverse / http://127.0.0.1:8080/signserver/process
&lt;/VirtualHost>
</source>
                </section>


                <section name="Setting up an Apache Web Server with mod_jk in front of SignServer">
                    <p>
Instead of using a mod_proxy you can use mod_jk which uses a JK connector between apache and tomcat.
You can easily combine it with mod_rewrite to change URLs.
                    </p>
                    <p>
This section will show you how to use an Apache with mod_jk in front of SignServer.
mod_jk have many features and by using it you can virtually do anything you want with hosts, ports and URLs.
                    </p><p>
This example was created on Ubuntu 64-bit Server 8.10 using the Apache Web Server 2.2 package,
but should be easy to adapt to any system able to run Apache.
                    </p>
<source>
# sudo apt-get install apache2 libapache2-mod-jk
# vim /etc/libapache2-mod-jk/workers.properties
-----
worker.list=jboss

# Define a worker using ajp13
worker.jboss.port=8009
worker.jboss.host=127.0.0.1
worker.jboss.type=ajp13
-----
</source>
<source>
# cd /etc/apache2/mods-enabled
# ln -s ../mods-available/rewrite.load rewrite.load
# vim /etc/apache2/sites-available/tsa.primekey.se
-----
&lt;VirtualHost tsa.company.com:80&gt;
ServerAdmin webmaster@company.com
ServerName tsa.company.com
ServerAlias tsa.company.com

JkLogFile /var/log/apache2/mod_jk.log
JkLogLevel debug
JkMount /* jboss
JkMount / jboss
&lt;/VirtualHost&gt;
-----
</source>
Enable tsa.primekey.se in /etc/apache2/sites-enabled

<source>
# vim /etc/apache2/mods-available/jk.load
-----
LoadModule /usr/lib/apache2/modules/mod_jk.so
JkWorkersFile /etc/libapache2-mod-jk/workers.properties
-----
</source>
                    <p>
Finally restart apache and you can run:
                    </p>
<source>
$ bin/client.sh timestamp http://tsa.company.com/signserver/process?workerName=TSA
</source>
                </section>
        </chapter>

    </body>
</document>

