/************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 *
 * Copyright 2008 Sun Microsystems, Inc. All rights reserved.
 *
 * Use is subject to license terms.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0. You can also
 * obtain a copy of the License at http://odftoolkit.org/docs/license.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ************************************************************************/

package org.odftoolkit.odfdom.doc.table;

import java.util.List;

import org.odftoolkit.odfdom.OdfFileDom;
import org.odftoolkit.odfdom.doc.style.OdfStyle;
import org.odftoolkit.odfdom.doc.text.OdfTextParagraph;
import org.odftoolkit.odfdom.dom.attribute.office.OfficeValueTypeAttribute;
import org.odftoolkit.odfdom.dom.element.table.TableCoveredTableCellElement;
import org.odftoolkit.odfdom.dom.element.table.TableTableCellElementBase;
import org.odftoolkit.odfdom.dom.element.table.TableTableRowElement;
import org.odftoolkit.odfdom.type.PositiveInteger;
import org.w3c.dom.DOMException;
import org.w3c.dom.Node;

/**
 * Convenient functionalty for the parent ODF OpenDocument element
 *
 */
public class OdfTableRow extends TableTableRowElement
{

	private OdfStyle m_defaultCellStyle;
	private int mCurrentNumberOfColumns = 0;

    /** Creates a new instance of this class
     * @param ownerDoc the OdfFileDom the OdfTableRow should be inserted
     */
    public OdfTableRow(OdfFileDom ownerDoc) {
        super(ownerDoc);
    }

    //@Override
    public OdfTable getTable() {
        return getAncestorAs(OdfTable.class);
    }

    public Node removeCell(Node remChild) throws DOMException {
        if (remChild instanceof OdfTableCell) {
            OdfTableCell td = (OdfTableCell) remChild;
            int nColSpan = td.getTableNumberColumnsRepeatedAttribute().intValue();
            int nColRepeat = td.getTableNumberColumnsRepeatedAttribute().intValue();
            int nColVanish = Math.max(nColSpan, nColRepeat);
            mCurrentNumberOfColumns -= nColVanish;
        }
        return super.removeChild(remChild);
    }

    public Node appendCell(Node newChild) throws DOMException {

        // If a covered cell is inserted which is not auto generated,
        // then we have to check whether this replaces an auto generated
        // covered cell that is been inserted previously
        // covered cells have been inserted automatically. We have to
        // replace the first auto generated node we find, but have to stop the
        // (backward) search whenever we find a non auto generated cell.
        OdfCoveredTableCell aOldCoveredCell = null;
        if (newChild instanceof OdfCoveredTableCell &&
                !((OdfCoveredTableCell) newChild).isAutoGenerated()) {
            Node aTestNode = super.getLastChild();
            while (aTestNode != null) {
                if (aTestNode instanceof OdfCoveredTableCell) {
                    if (((OdfCoveredTableCell) aTestNode).isAutoGenerated()) {
                        aOldCoveredCell = (OdfCoveredTableCell) aTestNode;
                    } else {
                        break;
                    }
                } else if (aTestNode instanceof OdfTableCell) {
                    break;
                }
                aTestNode = aTestNode.getPreviousSibling();
            }
        }

        Node aNode = null;
        if (aOldCoveredCell != null) {
            ((OdfCoveredTableCell) newChild).setNumberRowsSpanned(aOldCoveredCell.getNumberRowsSpanned());
            ((OdfCoveredTableCell) newChild).setNumberColumnsSpanned(aOldCoveredCell.getNumberColumnsSpanned());
            aNode = newChild;
            Node nextCovered = aOldCoveredCell.getNextSibling();
            replaceChild(newChild, aOldCoveredCell);

            // in case the table cell is repeated, we have to remove up to repeat autogenerated
            // covered cells:
            int repeated = ((OdfCoveredTableCell)newChild).getTableNumberColumnsRepeatedAttribute().intValue();
            while (repeated > 1 && nextCovered != null && nextCovered instanceof OdfCoveredTableCell &&
                    ((OdfCoveredTableCell) nextCovered).isAutoGenerated()) {
                Node removeNode = nextCovered;
                nextCovered = nextCovered.getNextSibling();
                removeChild(removeNode);
                --repeated;
                --mCurrentNumberOfColumns;
            }
        } else {
            aNode = super.appendChild(newChild);
        }

        if (aNode instanceof OdfTableCell) {
            OdfTableCell td = (OdfTableCell) aNode;
            Integer tableNumberColumnsSpannedAttribute = td.getTableNumberColumnsSpannedAttribute();
            int nColSpan = 0;
            if (tableNumberColumnsSpannedAttribute != null) {
                nColSpan = tableNumberColumnsSpannedAttribute.intValue();
            }
            Integer tableNumberColumnsRepeatedAttribute = td.getTableNumberColumnsRepeatedAttribute();
            int nColRepeat = 0;
            if (tableNumberColumnsRepeatedAttribute != null)
                nColRepeat = tableNumberColumnsRepeatedAttribute.intValue();
            int nStartCol = mCurrentNumberOfColumns; // optimization
            //int nStartCol = td.getColumnIndex();
            int nColAdd = Math.max(nColSpan, nColRepeat);
            int nEndCol = nStartCol + nColAdd;

            // take care of table columns
            // if there is no table column forthis element create new
            // table columns
            OdfTable table = getTable();
            if (table != null) {
                int count = table.getTableColumnCount(); // table.getCurrentNumberOfColumns(); => member;
                if (count < nEndCol) {
                    if(nColRepeat > 1){
                        table.addTableColumn(nEndCol - count); // sets member at table!
                    }else{
                        for(int i = 0; i < nEndCol - count; ++i){
                            table.addTableColumn(1); // sets member at table!
                        }
                    }
                }
            }

            mCurrentNumberOfColumns += nColAdd;

            if (nColSpan > 1) {
                appendCoveredCells(nColSpan - 1, td.getTableNumberRowsSpannedAttribute().intValue(), aNode);
            }
            inheritSpannedCells(nEndCol);
        }
        return aNode;
    }

    private void appendCoveredCells(int nColSpan, int nRowSpan, Node aNode) {
        while (nColSpan > 0) {
            OdfCoveredTableCell aCTC =
                    (OdfCoveredTableCell) getOwnerDocument().createElementNS(
                    TableCoveredTableCellElement.ELEMENT_NAME.getUri(),
                    TableCoveredTableCellElement.ELEMENT_NAME.getQName());
            aCTC.setNumberColumnsSpanned(new PositiveInteger(nColSpan));
            aCTC.setNumberRowsSpanned(new PositiveInteger(nRowSpan));
            aCTC.setAutoGenerated();
            appendChild(aCTC);

            --nColSpan;
        }
    }

    public void inheritSpannedCells(int nCol) {
        OdfTableRow aPrevRow = getPreviousRow();
        if (aPrevRow == null) {
            return;
        }

        Node aUpperNode = aPrevRow.getCellAt(nCol);
        if (aUpperNode == null) {
            return;
        }

        int nCoveredCellsToAdd = 0;
        int nUpperRowSpan = 1;
        if (aUpperNode instanceof OdfTableCell) {
            OdfTableCell aUpperCell = (OdfTableCell) aUpperNode;
            nUpperRowSpan = aUpperCell.getTableNumberRowsSpannedAttribute().intValue();
            if (nUpperRowSpan > 1) {
                nCoveredCellsToAdd = aUpperCell.getTableNumberColumnsSpannedAttribute().intValue();
            }
        }
        if (aUpperNode instanceof OdfCoveredTableCell) {
            OdfCoveredTableCell aUpperCell = (OdfCoveredTableCell) aUpperNode;
            nUpperRowSpan = aUpperCell.getNumberRowsSpanned().intValue();
            if (nUpperRowSpan > 1) {

                nCoveredCellsToAdd = aUpperCell.getNumberColumnsSpanned().intValue();
            }
        }
        if (nCoveredCellsToAdd == 0) {
            return;
        }

        mCurrentNumberOfColumns += nCoveredCellsToAdd;
        appendCoveredCells(nCoveredCellsToAdd, nUpperRowSpan - 1, null);

    }

    public OdfTableRow getPreviousRow() {
        Node aPrevNode = getPreviousSibling();
        while (aPrevNode != null) {
            if (aPrevNode instanceof OdfTableRow) {
                return (OdfTableRow) aPrevNode;
            }
            /*if( aPrevNode instanceof OdfTableTableHeaderRows )
            {
            OdfTableTableHeaderRows aRows = (OdfTableTableHeaderRows)aPrevNode;
            return aRows.getPreviousRow();
            }*/
            aPrevNode = aPrevNode.getPreviousSibling();
        }
        /*if( aPrevNode == null )
        {
        Node aParentNode = getParentNode();
        if( aParentNode != null && aParentNode instanceof OdfTableTableRowContainer )
        {
        OdfTableTableRowContainer aRows = (OdfTableTableRowContainer)aParentNode;
        return aRows.getPreviousRow();
        }
        }*/

        return null;
    }

    public Node getCellAt(int nCol) {
        for (Node n : new DomNodeList(getChildNodes())) {
            if (n instanceof OdfTableCell ||
                    n instanceof OdfCoveredTableCell) {
                if (nCol == 0) {
                    return n;
                } else {
                    nCol = nCol - ((TableTableCellElementBase) n).getTableNumberColumnsRepeatedAttribute().intValue();
                }
            }
        }

        return null;
    }

    /**
	 * Populate a row with strings.
	 * If the <code>cellStyleList</code> or
	 * <code>paraStyleList</code> is shorter than the <code>stringList</code>,
	 * the values will be recycled. Thus, if you want all the cells to have
	 * the same cell style, just put one item in <code>cellStyleList</code>.
	 * @param valueList a <code>List&lt;String&gt;</code> containing
	 * cell values.
	 * @param cellStyleList a <code>List&lt;String&gt;</code> containing
	 * cell style names.
	 * @param paraStyleList a <code>List&lt;String&gt;</code> containing
	 * paragraph style names.
	 */
	public void populateStrings(List<String> valueList,
		List<String> cellStyleList,	List<String> paraStyleList)
	{
		int cellIndex = 0;
		int paraIndex = 0;
		OdfTableCell cell;
		OdfTextParagraph para;

		for (String value : valueList)
		{
			cell = new OdfTableCell((OdfFileDom)this.getOwnerDocument());
			cell.setTableStyleNameAttribute(cellStyleList.get(cellIndex));
			cell.setOfficeTimeValueAttribute(value);
			cell.setOfficeValueTypeAttribute(OfficeValueTypeAttribute.Value.STRING.toString());
			para = new OdfTextParagraph((OdfFileDom)this.getOwnerDocument(),
				paraStyleList.get(paraIndex), value);
			cell.appendChild(para);
			this.appendCell(cell);

			/* advance style indices, wrapping around if necessary */
			cellIndex = (cellIndex + 1) % cellStyleList.size();
			paraIndex = (paraIndex + 1) % paraStyleList.size();
}
	}


    public void setDefaultCellStyle(OdfStyle s) {
        if (m_defaultCellStyle != null) {
            m_defaultCellStyle.removeStyleUser(this);
        }
        m_defaultCellStyle = s;
        if (m_defaultCellStyle != null) {
            m_defaultCellStyle.addStyleUser(this);
            this.setTableDefaultCellStyleNameAttribute(
                    m_defaultCellStyle.getStyleNameAttribute());
        }
    }

    public OdfStyle getDefaultCellStyle() {
        return m_defaultCellStyle;
    }
}
